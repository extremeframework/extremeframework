/* Modernizr 2.8.3 (Custom Build) | MIT & BSD
 * Build: http://modernizr.com/download/#-touch-shiv-cssclasses-teststyles-prefixes
 */
;
window.Modernizr = function(a, b, c) {
    function w(a) {
        j.cssText = a
    }

    function x(a, b) {
        return w(m.join(a + ";") + (b || ""))
    }

    function y(a, b) {
        return typeof a === b
    }

    function z(a, b) {
        return !!~("" + a).indexOf(b)
    }

    function A(a, b, d) {
        for (var e in a) {
            var f = b[a[e]];
            if (f !== c) return d === !1 ? a[e] : y(f, "function") ? f.bind(d || b) : f
        }
        return !1
    }
    var d = "2.8.3",
        e = {},
        f = !0,
        g = b.documentElement,
        h = "modernizr",
        i = b.createElement(h),
        j = i.style,
        k, l = {}.toString,
        m = " -webkit- -moz- -o- -ms- ".split(" "),
        n = {},
        o = {},
        p = {},
        q = [],
        r = q.slice,
        s, t = function(a, c, d, e) {
            var f, i, j, k, l = b.createElement("div"),
                m = b.body,
                n = m || b.createElement("body");
            if (parseInt(d, 10))
                while (d--) j = b.createElement("div"), j.id = e ? e[d] : h + (d + 1), l.appendChild(j);
            return f = ["&#173;", '<style id="s', h, '">', a, "</style>"].join(""), l.id = h, (m ? l : n).innerHTML += f, n.appendChild(l), m || (n.style.background = "", n.style.overflow = "hidden", k = g.style.overflow, g.style.overflow = "hidden", g.appendChild(n)), i = c(l, a), m ? l.parentNode.removeChild(l) : (n.parentNode.removeChild(n), g.style.overflow = k), !!i
        },
        u = {}.hasOwnProperty,
        v;
    !y(u, "undefined") && !y(u.call, "undefined") ? v = function(a, b) {
        return u.call(a, b)
    } : v = function(a, b) {
        return b in a && y(a.constructor.prototype[b], "undefined")
    }, Function.prototype.bind || (Function.prototype.bind = function(b) {
        var c = this;
        if (typeof c != "function") throw new TypeError;
        var d = r.call(arguments, 1),
            e = function() {
                if (this instanceof e) {
                    var a = function() {};
                    a.prototype = c.prototype;
                    var f = new a,
                        g = c.apply(f, d.concat(r.call(arguments)));
                    return Object(g) === g ? g : f
                }
                return c.apply(b, d.concat(r.call(arguments)))
            };
        return e
    }), n.touch = function() {
        var c;
        return "ontouchstart" in a || a.DocumentTouch && b instanceof DocumentTouch ? c = !0 : t(["@media (", m.join("touch-enabled),("), h, ")", "{#modernizr{top:9px;position:absolute}}"].join(""), function(a) {
            c = a.offsetTop === 9
        }), c
    };
    for (var B in n) v(n, B) && (s = B.toLowerCase(), e[s] = n[B](), q.push((e[s] ? "" : "no-") + s));
    return e.addTest = function(a, b) {
            if (typeof a == "object")
                for (var d in a) v(a, d) && e.addTest(d, a[d]);
            else {
                a = a.toLowerCase();
                if (e[a] !== c) return e;
                b = typeof b == "function" ? b() : b, typeof f != "undefined" && f && (g.className += " " + (b ? "" : "no-") + a), e[a] = b
            }
            return e
        }, w(""), i = k = null,
        function(a, b) {
            function l(a, b) {
                var c = a.createElement("p"),
                    d = a.getElementsByTagName("head")[0] || a.documentElement;
                return c.innerHTML = "x<style>" + b + "</style>", d.insertBefore(c.lastChild, d.firstChild)
            }

            function m() {
                var a = s.elements;
                return typeof a == "string" ? a.split(" ") : a
            }

            function n(a) {
                var b = j[a[h]];
                return b || (b = {}, i++, a[h] = i, j[i] = b), b
            }

            function o(a, c, d) {
                c || (c = b);
                if (k) return c.createElement(a);
                d || (d = n(c));
                var g;
                return d.cache[a] ? g = d.cache[a].cloneNode() : f.test(a) ? g = (d.cache[a] = d.createElem(a)).cloneNode() : g = d.createElem(a), g.canHaveChildren && !e.test(a) && !g.tagUrn ? d.frag.appendChild(g) : g
            }

            function p(a, c) {
                a || (a = b);
                if (k) return a.createDocumentFragment();
                c = c || n(a);
                var d = c.frag.cloneNode(),
                    e = 0,
                    f = m(),
                    g = f.length;
                for (; e < g; e++) d.createElement(f[e]);
                return d
            }

            function q(a, b) {
                b.cache || (b.cache = {}, b.createElem = a.createElement, b.createFrag = a.createDocumentFragment, b.frag = b.createFrag()), a.createElement = function(c) {
                    return s.shivMethods ? o(c, a, b) : b.createElem(c)
                }, a.createDocumentFragment = Function("h,f", "return function(){var n=f.cloneNode(),c=n.createElement;h.shivMethods&&(" + m().join().replace(/[\w\-]+/g, function(a) {
                    return b.createElem(a), b.frag.createElement(a), 'c("' + a + '")'
                }) + ");return n}")(s, b.frag)
            }

            function r(a) {
                a || (a = b);
                var c = n(a);
                return s.shivCSS && !g && !c.hasCSS && (c.hasCSS = !!l(a, "article,aside,dialog,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}mark{background:#FF0;color:#000}template{display:none}")), k || q(a, c), a
            }
            var c = "3.7.0",
                d = a.html5 || {},
                e = /^<|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i,
                f = /^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$/i,
                g, h = "_html5shiv",
                i = 0,
                j = {},
                k;
            (function() {
                try {
                    var a = b.createElement("a");
                    a.innerHTML = "<xyz></xyz>", g = "hidden" in a, k = a.childNodes.length == 1 || function() {
                        b.createElement("a");
                        var a = b.createDocumentFragment();
                        return typeof a.cloneNode == "undefined" || typeof a.createDocumentFragment == "undefined" || typeof a.createElement == "undefined"
                    }()
                } catch (c) {
                    g = !0, k = !0
                }
            })();
            var s = {
                elements: d.elements || "abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video",
                version: c,
                shivCSS: d.shivCSS !== !1,
                supportsUnknownElements: k,
                shivMethods: d.shivMethods !== !1,
                type: "default",
                shivDocument: r,
                createElement: o,
                createDocumentFragment: p
            };
            a.html5 = s, r(b)
        }(this, b), e._version = d, e._prefixes = m, e.testStyles = t, g.className = g.className.replace(/(^|\s)no-js(\s|$)/, "$1$2") + (f ? " js " + q.join(" ") : ""), e
}(this, this.document);

/*!
 * iScroll v4.2.5 ~ Copyright (c) 2012 Matteo Spinelli, http://cubiq.org
 * Released under MIT license, http://cubiq.org/license
 */
(function(window, doc) {
    var m = Math,
        dummyStyle = doc.createElement('div').style,
        vendor = (function() {
            var vendors = 't,webkitT,MozT,msT,OT'.split(','),
                t,
                i = 0,
                l = vendors.length;

            for (; i < l; i++) {
                t = vendors[i] + 'ransform';
                if (t in dummyStyle) {
                    return vendors[i].substr(0, vendors[i].length - 1);
                }
            }

            return false;
        })(),
        cssVendor = vendor ? '-' + vendor.toLowerCase() + '-' : '',

        // Style properties
        transform = prefixStyle('transform'),
        transitionProperty = prefixStyle('transitionProperty'),
        transitionDuration = prefixStyle('transitionDuration'),
        transformOrigin = prefixStyle('transformOrigin'),
        transitionTimingFunction = prefixStyle('transitionTimingFunction'),
        transitionDelay = prefixStyle('transitionDelay'),

        // Browser capabilities
        isAndroid = (/android/gi).test(navigator.appVersion),
        isIDevice = (/iphone|ipad/gi).test(navigator.appVersion),
        isTouchPad = (/hp-tablet/gi).test(navigator.appVersion),

        has3d = prefixStyle('perspective') in dummyStyle,
        hasTouch = 'ontouchstart' in window && !isTouchPad,
        hasTransform = vendor !== false,
        hasTransitionEnd = prefixStyle('transition') in dummyStyle,

        RESIZE_EV = 'onorientationchange' in window ? 'orientationchange' : 'resize',
        START_EV = hasTouch ? 'touchstart' : 'mousedown',
        MOVE_EV = hasTouch ? 'touchmove' : 'mousemove',
        END_EV = hasTouch ? 'touchend' : 'mouseup',
        CANCEL_EV = hasTouch ? 'touchcancel' : 'mouseup',
        TRNEND_EV = (function() {
            if (vendor === false) return false;

            var transitionEnd = {
                '': 'transitionend',
                'webkit': 'webkitTransitionEnd',
                'Moz': 'transitionend',
                'O': 'otransitionend',
                'ms': 'MSTransitionEnd'
            };

            return transitionEnd[vendor];
        })(),

        nextFrame = (function() {
            return window.requestAnimationFrame ||
                window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame ||
                window.oRequestAnimationFrame ||
                window.msRequestAnimationFrame ||
                function(callback) {
                    return setTimeout(callback, 1);
                };
        })(),
        cancelFrame = (function() {
            return window.cancelRequestAnimationFrame ||
                window.webkitCancelAnimationFrame ||
                window.webkitCancelRequestAnimationFrame ||
                window.mozCancelRequestAnimationFrame ||
                window.oCancelRequestAnimationFrame ||
                window.msCancelRequestAnimationFrame ||
                clearTimeout;
        })(),

        // Helpers
        translateZ = has3d ? ' translateZ(0)' : '',

        // Constructor
        iScroll = function(el, options) {
            var that = this,
                i;

            that.wrapper = typeof el == 'object' ? el : doc.getElementById(el);
            that.wrapper.style.overflow = 'hidden';
            that.scroller = that.wrapper.children[0];

            // Default options
            that.options = {
                hScroll: true,
                vScroll: true,
                x: 0,
                y: 0,
                bounce: true,
                bounceLock: false,
                momentum: true,
                lockDirection: true,
                useTransform: true,
                useTransition: false,
                topOffset: 0,
                checkDOMChanges: false, // Experimental
                handleClick: true,

                // Scrollbar
                hScrollbar: true,
                vScrollbar: true,
                fixedScrollbar: isAndroid,
                hideScrollbar: isIDevice,
                fadeScrollbar: isIDevice && has3d,
                scrollbarClass: '',

                // Zoom
                zoom: false,
                zoomMin: 1,
                zoomMax: 4,
                doubleTapZoom: 2,
                wheelAction: 'scroll',

                // Snap
                snap: false,
                snapThreshold: 1,

                // Events
                onRefresh: null,
                onBeforeScrollStart: function(e) {
                    e.preventDefault();
                },
                onScrollStart: null,
                onBeforeScrollMove: null,
                onScrollMove: null,
                onBeforeScrollEnd: null,
                onScrollEnd: null,
                onTouchEnd: null,
                onDestroy: null,
                onZoomStart: null,
                onZoom: null,
                onZoomEnd: null
            };

            // User defined options
            for (i in options) that.options[i] = options[i];

            // Set starting position
            that.x = that.options.x;
            that.y = that.options.y;

            // Normalize options
            that.options.useTransform = hasTransform && that.options.useTransform;
            that.options.hScrollbar = that.options.hScroll && that.options.hScrollbar;
            that.options.vScrollbar = that.options.vScroll && that.options.vScrollbar;
            that.options.zoom = that.options.useTransform && that.options.zoom;
            that.options.useTransition = hasTransitionEnd && that.options.useTransition;

            // Helpers FIX ANDROID BUG!
            // translate3d and scale doesn't work together!
            // Ignoring 3d ONLY WHEN YOU SET that.options.zoom
            if (that.options.zoom && isAndroid) {
                translateZ = '';
            }

            // Set some default styles
            that.scroller.style[transitionProperty] = that.options.useTransform ? cssVendor + 'transform' : 'top left';
            that.scroller.style[transitionDuration] = '0';
            that.scroller.style[transformOrigin] = '0 0';
            if (that.options.useTransition) that.scroller.style[transitionTimingFunction] = 'cubic-bezier(0.33,0.66,0.66,1)';

            if (that.options.useTransform) that.scroller.style[transform] = 'translate(' + that.x + 'px,' + that.y + 'px)' + translateZ;
            else that.scroller.style.cssText += ';position:absolute;top:' + that.y + 'px;left:' + that.x + 'px';

            if (that.options.useTransition) that.options.fixedScrollbar = true;

            that.refresh();

            that._bind(RESIZE_EV, window);
            that._bind(START_EV);
            if (!hasTouch) {
                if (that.options.wheelAction != 'none') {
                    that._bind('DOMMouseScroll');
                    that._bind('mousewheel');
                }
            }

            if (that.options.checkDOMChanges) that.checkDOMTime = setInterval(function() {
                that._checkDOMChanges();
            }, 500);
        };

    // Prototype
    iScroll.prototype = {
        enabled: true,
        x: 0,
        y: 0,
        steps: [],
        scale: 1,
        currPageX: 0,
        currPageY: 0,
        pagesX: [],
        pagesY: [],
        aniTime: null,
        wheelZoomCount: 0,

        handleEvent: function(e) {
            var that = this;
            switch (e.type) {
                case START_EV:
                    if (!hasTouch && e.button !== 0) return;
                    that._start(e);
                    break;
                case MOVE_EV:
                    that._move(e);
                    break;
                case END_EV:
                case CANCEL_EV:
                    that._end(e);
                    break;
                case RESIZE_EV:
                    that._resize();
                    break;
                case 'DOMMouseScroll':
                case 'mousewheel':
                    that._wheel(e);
                    break;
                case TRNEND_EV:
                    that._transitionEnd(e);
                    break;
            }
        },

        _checkDOMChanges: function() {
            if (this.moved || this.zoomed || this.animating ||
                (this.scrollerW == this.scroller.offsetWidth * this.scale && this.scrollerH == this.scroller.offsetHeight * this.scale)) return;

            this.refresh();
        },

        _scrollbar: function(dir) {
            var that = this,
                bar;

            if (!that[dir + 'Scrollbar']) {
                if (that[dir + 'ScrollbarWrapper']) {
                    if (hasTransform) that[dir + 'ScrollbarIndicator'].style[transform] = '';
                    that[dir + 'ScrollbarWrapper'].parentNode.removeChild(that[dir + 'ScrollbarWrapper']);
                    that[dir + 'ScrollbarWrapper'] = null;
                    that[dir + 'ScrollbarIndicator'] = null;
                }

                return;
            }

            if (!that[dir + 'ScrollbarWrapper']) {
                // Create the scrollbar wrapper
                bar = doc.createElement('div');

                if (that.options.scrollbarClass) bar.className = that.options.scrollbarClass + dir.toUpperCase();
                else bar.style.cssText = 'position:absolute;z-index:100;' + (dir == 'h' ? 'height:7px;bottom:1px;left:2px;right:' + (that.vScrollbar ? '7' : '2') + 'px' : 'width:7px;bottom:' + (that.hScrollbar ? '7' : '2') + 'px;top:2px;right:1px');

                bar.style.cssText += ';pointer-events:none;' + cssVendor + 'transition-property:opacity;' + cssVendor + 'transition-duration:' + (that.options.fadeScrollbar ? '350ms' : '0') + ';overflow:hidden;opacity:' + (that.options.hideScrollbar ? '0' : '1');

                that.wrapper.appendChild(bar);
                that[dir + 'ScrollbarWrapper'] = bar;

                // Create the scrollbar indicator
                bar = doc.createElement('div');
                if (!that.options.scrollbarClass) {
                    bar.style.cssText = 'position:absolute;z-index:100;background:rgba(0,0,0,0.5);border:1px solid rgba(255,255,255,0.9);' + cssVendor + 'background-clip:padding-box;' + cssVendor + 'box-sizing:border-box;' + (dir == 'h' ? 'height:100%' : 'width:100%') + ';' + cssVendor + 'border-radius:3px;border-radius:3px';
                }
                bar.style.cssText += ';pointer-events:none;' + cssVendor + 'transition-property:' + cssVendor + 'transform;' + cssVendor + 'transition-timing-function:cubic-bezier(0.33,0.66,0.66,1);' + cssVendor + 'transition-duration:0;' + cssVendor + 'transform: translate(0,0)' + translateZ;
                if (that.options.useTransition) bar.style.cssText += ';' + cssVendor + 'transition-timing-function:cubic-bezier(0.33,0.66,0.66,1)';

                that[dir + 'ScrollbarWrapper'].appendChild(bar);
                that[dir + 'ScrollbarIndicator'] = bar;
            }

            if (dir == 'h') {
                that.hScrollbarSize = that.hScrollbarWrapper.clientWidth;
                that.hScrollbarIndicatorSize = m.max(m.round(that.hScrollbarSize * that.hScrollbarSize / that.scrollerW), 8);
                that.hScrollbarIndicator.style.width = that.hScrollbarIndicatorSize + 'px';
                that.hScrollbarMaxScroll = that.hScrollbarSize - that.hScrollbarIndicatorSize;
                that.hScrollbarProp = that.hScrollbarMaxScroll / that.maxScrollX;
            } else {
                that.vScrollbarSize = that.vScrollbarWrapper.clientHeight;
                that.vScrollbarIndicatorSize = m.max(m.round(that.vScrollbarSize * that.vScrollbarSize / that.scrollerH), 8);
                that.vScrollbarIndicator.style.height = that.vScrollbarIndicatorSize + 'px';
                that.vScrollbarMaxScroll = that.vScrollbarSize - that.vScrollbarIndicatorSize;
                that.vScrollbarProp = that.vScrollbarMaxScroll / that.maxScrollY;
            }

            // Reset position
            that._scrollbarPos(dir, true);
        },

        _resize: function() {
            var that = this;
            setTimeout(function() {
                that.refresh();
            }, isAndroid ? 200 : 0);
        },

        _pos: function(x, y) {
            if (this.zoomed) return;

            x = this.hScroll ? x : 0;
            y = this.vScroll ? y : 0;

            if (this.options.useTransform) {
                this.scroller.style[transform] = 'translate(' + x + 'px,' + y + 'px) scale(' + this.scale + ')' + translateZ;
            } else {
                x = m.round(x);
                y = m.round(y);
                this.scroller.style.left = x + 'px';
                this.scroller.style.top = y + 'px';
            }

            this.x = x;
            this.y = y;

            this._scrollbarPos('h');
            this._scrollbarPos('v');
        },

        _scrollbarPos: function(dir, hidden) {
            var that = this,
                pos = dir == 'h' ? that.x : that.y,
                size;

            if (!that[dir + 'Scrollbar']) return;

            pos = that[dir + 'ScrollbarProp'] * pos;

            if (pos < 0) {
                if (!that.options.fixedScrollbar) {
                    size = that[dir + 'ScrollbarIndicatorSize'] + m.round(pos * 3);
                    if (size < 8) size = 8;
                    that[dir + 'ScrollbarIndicator'].style[dir == 'h' ? 'width' : 'height'] = size + 'px';
                }
                pos = 0;
            } else if (pos > that[dir + 'ScrollbarMaxScroll']) {
                if (!that.options.fixedScrollbar) {
                    size = that[dir + 'ScrollbarIndicatorSize'] - m.round((pos - that[dir + 'ScrollbarMaxScroll']) * 3);
                    if (size < 8) size = 8;
                    that[dir + 'ScrollbarIndicator'].style[dir == 'h' ? 'width' : 'height'] = size + 'px';
                    pos = that[dir + 'ScrollbarMaxScroll'] + (that[dir + 'ScrollbarIndicatorSize'] - size);
                } else {
                    pos = that[dir + 'ScrollbarMaxScroll'];
                }
            }

            that[dir + 'ScrollbarWrapper'].style[transitionDelay] = '0';
            that[dir + 'ScrollbarWrapper'].style.opacity = hidden && that.options.hideScrollbar ? '0' : '1';
            that[dir + 'ScrollbarIndicator'].style[transform] = 'translate(' + (dir == 'h' ? pos + 'px,0)' : '0,' + pos + 'px)') + translateZ;
        },

        _start: function(e) {
            var that = this,
                point = hasTouch ? e.touches[0] : e,
                matrix, x, y,
                c1, c2;

            if (!that.enabled) return;

            if (that.options.onBeforeScrollStart) that.options.onBeforeScrollStart.call(that, e);

            if (that.options.useTransition || that.options.zoom) that._transitionTime(0);

            that.moved = false;
            that.animating = false;
            that.zoomed = false;
            that.distX = 0;
            that.distY = 0;
            that.absDistX = 0;
            that.absDistY = 0;
            that.dirX = 0;
            that.dirY = 0;

            // Gesture start
            if (that.options.zoom && hasTouch && e.touches.length > 1) {
                c1 = m.abs(e.touches[0].pageX - e.touches[1].pageX);
                c2 = m.abs(e.touches[0].pageY - e.touches[1].pageY);
                that.touchesDistStart = m.sqrt(c1 * c1 + c2 * c2);

                that.originX = m.abs(e.touches[0].pageX + e.touches[1].pageX - that.wrapperOffsetLeft * 2) / 2 - that.x;
                that.originY = m.abs(e.touches[0].pageY + e.touches[1].pageY - that.wrapperOffsetTop * 2) / 2 - that.y;

                if (that.options.onZoomStart) that.options.onZoomStart.call(that, e);
            }

            if (that.options.momentum) {
                if (that.options.useTransform) {
                    // Very lame general purpose alternative to CSSMatrix
                    matrix = getComputedStyle(that.scroller, null)[transform].replace(/[^0-9\-.,]/g, '').split(',');
                    x = +(matrix[12] || matrix[4]);
                    y = +(matrix[13] || matrix[5]);
                } else {
                    x = +getComputedStyle(that.scroller, null).left.replace(/[^0-9-]/g, '');
                    y = +getComputedStyle(that.scroller, null).top.replace(/[^0-9-]/g, '');
                }

                if (x != that.x || y != that.y) {
                    if (that.options.useTransition) that._unbind(TRNEND_EV);
                    else cancelFrame(that.aniTime);
                    that.steps = [];
                    that._pos(x, y);
                    if (that.options.onScrollEnd) that.options.onScrollEnd.call(that);
                }
            }

            that.absStartX = that.x; // Needed by snap threshold
            that.absStartY = that.y;

            that.startX = that.x;
            that.startY = that.y;
            that.pointX = point.pageX;
            that.pointY = point.pageY;

            that.startTime = e.timeStamp || Date.now();

            if (that.options.onScrollStart) that.options.onScrollStart.call(that, e);

            that._bind(MOVE_EV, window);
            that._bind(END_EV, window);
            that._bind(CANCEL_EV, window);
        },

        _move: function(e) {
            var that = this,
                point = hasTouch ? e.touches[0] : e,
                deltaX = point.pageX - that.pointX,
                deltaY = point.pageY - that.pointY,
                newX = that.x + deltaX,
                newY = that.y + deltaY,
                c1, c2, scale,
                timestamp = e.timeStamp || Date.now();

            if (that.options.onBeforeScrollMove) that.options.onBeforeScrollMove.call(that, e);

            // Zoom
            if (that.options.zoom && hasTouch && e.touches.length > 1) {
                c1 = m.abs(e.touches[0].pageX - e.touches[1].pageX);
                c2 = m.abs(e.touches[0].pageY - e.touches[1].pageY);
                that.touchesDist = m.sqrt(c1 * c1 + c2 * c2);

                that.zoomed = true;

                scale = 1 / that.touchesDistStart * that.touchesDist * this.scale;

                if (scale < that.options.zoomMin) scale = 0.5 * that.options.zoomMin * Math.pow(2.0, scale / that.options.zoomMin);
                else if (scale > that.options.zoomMax) scale = 2.0 * that.options.zoomMax * Math.pow(0.5, that.options.zoomMax / scale);

                that.lastScale = scale / this.scale;

                newX = this.originX - this.originX * that.lastScale + this.x;
                newY = this.originY - this.originY * that.lastScale + this.y;

                this.scroller.style[transform] = 'translate(' + newX + 'px,' + newY + 'px) scale(' + scale + ')' + translateZ;

                if (that.options.onZoom) that.options.onZoom.call(that, e);
                return;
            }

            that.pointX = point.pageX;
            that.pointY = point.pageY;

            // Slow down if outside of the boundaries
            if (newX > 0 || newX < that.maxScrollX) {
                newX = that.options.bounce ? that.x + (deltaX / 2) : newX >= 0 || that.maxScrollX >= 0 ? 0 : that.maxScrollX;
            }
            if (newY > that.minScrollY || newY < that.maxScrollY) {
                newY = that.options.bounce ? that.y + (deltaY / 2) : newY >= that.minScrollY || that.maxScrollY >= 0 ? that.minScrollY : that.maxScrollY;
            }

            that.distX += deltaX;
            that.distY += deltaY;
            that.absDistX = m.abs(that.distX);
            that.absDistY = m.abs(that.distY);

            if (that.absDistX < 6 && that.absDistY < 6) {
                return;
            }

            // Lock direction
            if (that.options.lockDirection) {
                if (that.absDistX > that.absDistY + 5) {
                    newY = that.y;
                    deltaY = 0;
                } else if (that.absDistY > that.absDistX + 5) {
                    newX = that.x;
                    deltaX = 0;
                }
            }

            that.moved = true;
            that._pos(newX, newY);
            that.dirX = deltaX > 0 ? -1 : deltaX < 0 ? 1 : 0;
            that.dirY = deltaY > 0 ? -1 : deltaY < 0 ? 1 : 0;

            if (timestamp - that.startTime > 300) {
                that.startTime = timestamp;
                that.startX = that.x;
                that.startY = that.y;
            }

            if (that.options.onScrollMove) that.options.onScrollMove.call(that, e);
        },

        _end: function(e) {
            if (hasTouch && e.touches.length !== 0) return;

            var that = this,
                point = hasTouch ? e.changedTouches[0] : e,
                target, ev,
                momentumX = {
                    dist: 0,
                    time: 0
                },
                momentumY = {
                    dist: 0,
                    time: 0
                },
                duration = (e.timeStamp || Date.now()) - that.startTime,
                newPosX = that.x,
                newPosY = that.y,
                distX, distY,
                newDuration,
                snap,
                scale;

            that._unbind(MOVE_EV, window);
            that._unbind(END_EV, window);
            that._unbind(CANCEL_EV, window);

            if (that.options.onBeforeScrollEnd) that.options.onBeforeScrollEnd.call(that, e);

            if (that.zoomed) {
                scale = that.scale * that.lastScale;
                scale = Math.max(that.options.zoomMin, scale);
                scale = Math.min(that.options.zoomMax, scale);
                that.lastScale = scale / that.scale;
                that.scale = scale;

                that.x = that.originX - that.originX * that.lastScale + that.x;
                that.y = that.originY - that.originY * that.lastScale + that.y;

                that.scroller.style[transitionDuration] = '200ms';
                that.scroller.style[transform] = 'translate(' + that.x + 'px,' + that.y + 'px) scale(' + that.scale + ')' + translateZ;

                that.zoomed = false;
                that.refresh();

                if (that.options.onZoomEnd) that.options.onZoomEnd.call(that, e);
                return;
            }

            if (!that.moved) {
                if (hasTouch) {
                    if (that.doubleTapTimer && that.options.zoom) {
                        // Double tapped
                        clearTimeout(that.doubleTapTimer);
                        that.doubleTapTimer = null;
                        if (that.options.onZoomStart) that.options.onZoomStart.call(that, e);
                        that.zoom(that.pointX, that.pointY, that.scale == 1 ? that.options.doubleTapZoom : 1);
                        if (that.options.onZoomEnd) {
                            setTimeout(function() {
                                that.options.onZoomEnd.call(that, e);
                            }, 200); // 200 is default zoom duration
                        }
                    } else if (this.options.handleClick) {
                        that.doubleTapTimer = setTimeout(function() {
                            that.doubleTapTimer = null;

                            // Find the last touched element
                            target = point.target;
                            while (target.nodeType != 1) target = target.parentNode;

                            if (target.tagName != 'SELECT' && target.tagName != 'INPUT' && target.tagName != 'TEXTAREA') {
                                ev = doc.createEvent('MouseEvents');
                                ev.initMouseEvent('click', true, true, e.view, 1,
                                    point.screenX, point.screenY, point.clientX, point.clientY,
                                    e.ctrlKey, e.altKey, e.shiftKey, e.metaKey,
                                    0, null);
                                ev._fake = true;
                                target.dispatchEvent(ev);
                            }
                        }, that.options.zoom ? 250 : 0);
                    }
                }

                that._resetPos(400);

                if (that.options.onTouchEnd) that.options.onTouchEnd.call(that, e);
                return;
            }

            if (duration < 300 && that.options.momentum) {
                momentumX = newPosX ? that._momentum(newPosX - that.startX, duration, -that.x, that.scrollerW - that.wrapperW + that.x, that.options.bounce ? that.wrapperW : 0) : momentumX;
                momentumY = newPosY ? that._momentum(newPosY - that.startY, duration, -that.y, (that.maxScrollY < 0 ? that.scrollerH - that.wrapperH + that.y - that.minScrollY : 0), that.options.bounce ? that.wrapperH : 0) : momentumY;

                newPosX = that.x + momentumX.dist;
                newPosY = that.y + momentumY.dist;

                if ((that.x > 0 && newPosX > 0) || (that.x < that.maxScrollX && newPosX < that.maxScrollX)) momentumX = {
                    dist: 0,
                    time: 0
                };
                if ((that.y > that.minScrollY && newPosY > that.minScrollY) || (that.y < that.maxScrollY && newPosY < that.maxScrollY)) momentumY = {
                    dist: 0,
                    time: 0
                };
            }

            if (momentumX.dist || momentumY.dist) {
                newDuration = m.max(m.max(momentumX.time, momentumY.time), 10);

                // Do we need to snap?
                if (that.options.snap) {
                    distX = newPosX - that.absStartX;
                    distY = newPosY - that.absStartY;
                    if (m.abs(distX) < that.options.snapThreshold && m.abs(distY) < that.options.snapThreshold) {
                        that.scrollTo(that.absStartX, that.absStartY, 200);
                    } else {
                        snap = that._snap(newPosX, newPosY);
                        newPosX = snap.x;
                        newPosY = snap.y;
                        newDuration = m.max(snap.time, newDuration);
                    }
                }

                that.scrollTo(m.round(newPosX), m.round(newPosY), newDuration);

                if (that.options.onTouchEnd) that.options.onTouchEnd.call(that, e);
                return;
            }

            // Do we need to snap?
            if (that.options.snap) {
                distX = newPosX - that.absStartX;
                distY = newPosY - that.absStartY;
                if (m.abs(distX) < that.options.snapThreshold && m.abs(distY) < that.options.snapThreshold) that.scrollTo(that.absStartX, that.absStartY, 200);
                else {
                    snap = that._snap(that.x, that.y);
                    if (snap.x != that.x || snap.y != that.y) that.scrollTo(snap.x, snap.y, snap.time);
                }

                if (that.options.onTouchEnd) that.options.onTouchEnd.call(that, e);
                return;
            }

            that._resetPos(200);
            if (that.options.onTouchEnd) that.options.onTouchEnd.call(that, e);
        },

        _resetPos: function(time) {
            var that = this,
                resetX = that.x >= 0 ? 0 : that.x < that.maxScrollX ? that.maxScrollX : that.x,
                resetY = that.y >= that.minScrollY || that.maxScrollY > 0 ? that.minScrollY : that.y < that.maxScrollY ? that.maxScrollY : that.y;

            if (resetX == that.x && resetY == that.y) {
                if (that.moved) {
                    that.moved = false;
                    if (that.options.onScrollEnd) that.options.onScrollEnd.call(that); // Execute custom code on scroll end
                }

                if (that.hScrollbar && that.options.hideScrollbar) {
                    if (vendor == 'webkit') that.hScrollbarWrapper.style[transitionDelay] = '300ms';
                    that.hScrollbarWrapper.style.opacity = '0';
                }
                if (that.vScrollbar && that.options.hideScrollbar) {
                    if (vendor == 'webkit') that.vScrollbarWrapper.style[transitionDelay] = '300ms';
                    that.vScrollbarWrapper.style.opacity = '0';
                }

                return;
            }

            that.scrollTo(resetX, resetY, time || 0);
        },

        _wheel: function(e) {
            var that = this,
                wheelDeltaX, wheelDeltaY,
                deltaX, deltaY,
                deltaScale;

            if ('wheelDeltaX' in e) {
                wheelDeltaX = e.wheelDeltaX / 12;
                wheelDeltaY = e.wheelDeltaY / 12;
            } else if ('wheelDelta' in e) {
                wheelDeltaX = wheelDeltaY = e.wheelDelta / 12;
            } else if ('detail' in e) {
                wheelDeltaX = wheelDeltaY = -e.detail * 3;
            } else {
                return;
            }

            if (that.options.wheelAction == 'zoom') {
                deltaScale = that.scale * Math.pow(2, 1 / 3 * (wheelDeltaY ? wheelDeltaY / Math.abs(wheelDeltaY) : 0));
                if (deltaScale < that.options.zoomMin) deltaScale = that.options.zoomMin;
                if (deltaScale > that.options.zoomMax) deltaScale = that.options.zoomMax;

                if (deltaScale != that.scale) {
                    if (!that.wheelZoomCount && that.options.onZoomStart) that.options.onZoomStart.call(that, e);
                    that.wheelZoomCount++;

                    that.zoom(e.pageX, e.pageY, deltaScale, 400);

                    setTimeout(function() {
                        that.wheelZoomCount--;
                        if (!that.wheelZoomCount && that.options.onZoomEnd) that.options.onZoomEnd.call(that, e);
                    }, 400);
                }

                return;
            }

            deltaX = that.x + wheelDeltaX;
            deltaY = that.y + wheelDeltaY;

            if (deltaX > 0) deltaX = 0;
            else if (deltaX < that.maxScrollX) deltaX = that.maxScrollX;

            if (deltaY > that.minScrollY) deltaY = that.minScrollY;
            else if (deltaY < that.maxScrollY) deltaY = that.maxScrollY;

            if (that.maxScrollY < 0) {
                that.scrollTo(deltaX, deltaY, 0);
            }
        },

        _transitionEnd: function(e) {
            var that = this;

            if (e.target != that.scroller) return;

            that._unbind(TRNEND_EV);

            that._startAni();
        },


        /**
         *
         * Utilities
         *
         */
        _startAni: function() {
            var that = this,
                startX = that.x,
                startY = that.y,
                startTime = Date.now(),
                step, easeOut,
                animate;

            if (that.animating) return;

            if (!that.steps.length) {
                that._resetPos(400);
                return;
            }

            step = that.steps.shift();

            if (step.x == startX && step.y == startY) step.time = 0;

            that.animating = true;
            that.moved = true;

            if (that.options.useTransition) {
                that._transitionTime(step.time);
                that._pos(step.x, step.y);
                that.animating = false;
                if (step.time) that._bind(TRNEND_EV);
                else that._resetPos(0);
                return;
            }

            animate = function() {
                var now = Date.now(),
                    newX, newY;

                if (now >= startTime + step.time) {
                    that._pos(step.x, step.y);
                    that.animating = false;
                    if (that.options.onAnimationEnd) that.options.onAnimationEnd.call(that); // Execute custom code on animation end
                    that._startAni();
                    return;
                }

                now = (now - startTime) / step.time - 1;
                easeOut = m.sqrt(1 - now * now);
                newX = (step.x - startX) * easeOut + startX;
                newY = (step.y - startY) * easeOut + startY;
                that._pos(newX, newY);
                if (that.animating) that.aniTime = nextFrame(animate);
            };

            animate();
        },

        _transitionTime: function(time) {
            time += 'ms';
            this.scroller.style[transitionDuration] = time;
            if (this.hScrollbar) this.hScrollbarIndicator.style[transitionDuration] = time;
            if (this.vScrollbar) this.vScrollbarIndicator.style[transitionDuration] = time;
        },

        _momentum: function(dist, time, maxDistUpper, maxDistLower, size) {
            var deceleration = 0.0006,
                speed = m.abs(dist) / time,
                newDist = (speed * speed) / (2 * deceleration),
                newTime = 0,
                outsideDist = 0;

            // Proportinally reduce speed if we are outside of the boundaries
            if (dist > 0 && newDist > maxDistUpper) {
                outsideDist = size / (6 / (newDist / speed * deceleration));
                maxDistUpper = maxDistUpper + outsideDist;
                speed = speed * maxDistUpper / newDist;
                newDist = maxDistUpper;
            } else if (dist < 0 && newDist > maxDistLower) {
                outsideDist = size / (6 / (newDist / speed * deceleration));
                maxDistLower = maxDistLower + outsideDist;
                speed = speed * maxDistLower / newDist;
                newDist = maxDistLower;
            }

            newDist = newDist * (dist < 0 ? -1 : 1);
            newTime = speed / deceleration;

            return {
                dist: newDist,
                time: m.round(newTime)
            };
        },

        _offset: function(el) {
            var left = -el.offsetLeft,
                top = -el.offsetTop;

            while (el = el.offsetParent) {
                left -= el.offsetLeft;
                top -= el.offsetTop;
            }

            if (el != this.wrapper) {
                left *= this.scale;
                top *= this.scale;
            }

            return {
                left: left,
                top: top
            };
        },

        _snap: function(x, y) {
            var that = this,
                i, l,
                page, time,
                sizeX, sizeY;

            // Check page X
            page = that.pagesX.length - 1;
            for (i = 0, l = that.pagesX.length; i < l; i++) {
                if (x >= that.pagesX[i]) {
                    page = i;
                    break;
                }
            }
            if (page == that.currPageX && page > 0 && that.dirX < 0) page--;
            x = that.pagesX[page];
            sizeX = m.abs(x - that.pagesX[that.currPageX]);
            sizeX = sizeX ? m.abs(that.x - x) / sizeX * 500 : 0;
            that.currPageX = page;

            // Check page Y
            page = that.pagesY.length - 1;
            for (i = 0; i < page; i++) {
                if (y >= that.pagesY[i]) {
                    page = i;
                    break;
                }
            }
            if (page == that.currPageY && page > 0 && that.dirY < 0) page--;
            y = that.pagesY[page];
            sizeY = m.abs(y - that.pagesY[that.currPageY]);
            sizeY = sizeY ? m.abs(that.y - y) / sizeY * 500 : 0;
            that.currPageY = page;

            // Snap with constant speed (proportional duration)
            time = m.round(m.max(sizeX, sizeY)) || 200;

            return {
                x: x,
                y: y,
                time: time
            };
        },

        _bind: function(type, el, bubble) {
            (el || this.scroller).addEventListener(type, this, !!bubble);
        },

        _unbind: function(type, el, bubble) {
            (el || this.scroller).removeEventListener(type, this, !!bubble);
        },


        /**
         *
         * Public methods
         *
         */
        destroy: function() {
            var that = this;

            that.scroller.style[transform] = '';

            // Remove the scrollbars
            that.hScrollbar = false;
            that.vScrollbar = false;
            that._scrollbar('h');
            that._scrollbar('v');

            // Remove the event listeners
            that._unbind(RESIZE_EV, window);
            that._unbind(START_EV);
            that._unbind(MOVE_EV, window);
            that._unbind(END_EV, window);
            that._unbind(CANCEL_EV, window);

            if (!that.options.hasTouch) {
                that._unbind('DOMMouseScroll');
                that._unbind('mousewheel');
            }

            if (that.options.useTransition) that._unbind(TRNEND_EV);

            if (that.options.checkDOMChanges) clearInterval(that.checkDOMTime);

            if (that.options.onDestroy) that.options.onDestroy.call(that);
        },

        refresh: function() {
            var that = this,
                offset,
                i, l,
                els,
                pos = 0,
                page = 0;

            if (that.scale < that.options.zoomMin) that.scale = that.options.zoomMin;
            that.wrapperW = that.wrapper.clientWidth || 1;
            that.wrapperH = that.wrapper.clientHeight || 1;

            that.minScrollY = -that.options.topOffset || 0;
            that.scrollerW = m.round(that.scroller.offsetWidth * that.scale);
            that.scrollerH = m.round((that.scroller.offsetHeight + that.minScrollY) * that.scale);
            that.maxScrollX = that.wrapperW - that.scrollerW;
            that.maxScrollY = that.wrapperH - that.scrollerH + that.minScrollY;
            that.dirX = 0;
            that.dirY = 0;

            if (that.options.onRefresh) that.options.onRefresh.call(that);

            that.hScroll = that.options.hScroll && that.maxScrollX < 0;
            that.vScroll = that.options.vScroll && (!that.options.bounceLock && !that.hScroll || that.scrollerH > that.wrapperH);

            that.hScrollbar = that.hScroll && that.options.hScrollbar;
            that.vScrollbar = that.vScroll && that.options.vScrollbar && that.scrollerH > that.wrapperH;

            offset = that._offset(that.wrapper);
            that.wrapperOffsetLeft = -offset.left;
            that.wrapperOffsetTop = -offset.top;

            // Prepare snap
            if (typeof that.options.snap == 'string') {
                that.pagesX = [];
                that.pagesY = [];
                els = that.scroller.querySelectorAll(that.options.snap);
                for (i = 0, l = els.length; i < l; i++) {
                    pos = that._offset(els[i]);
                    pos.left += that.wrapperOffsetLeft;
                    pos.top += that.wrapperOffsetTop;
                    that.pagesX[i] = pos.left < that.maxScrollX ? that.maxScrollX : pos.left * that.scale;
                    that.pagesY[i] = pos.top < that.maxScrollY ? that.maxScrollY : pos.top * that.scale;
                }
            } else if (that.options.snap) {
                that.pagesX = [];
                while (pos >= that.maxScrollX) {
                    that.pagesX[page] = pos;
                    pos = pos - that.wrapperW;
                    page++;
                }
                if (that.maxScrollX % that.wrapperW) that.pagesX[that.pagesX.length] = that.maxScrollX - that.pagesX[that.pagesX.length - 1] + that.pagesX[that.pagesX.length - 1];

                pos = 0;
                page = 0;
                that.pagesY = [];
                while (pos >= that.maxScrollY) {
                    that.pagesY[page] = pos;
                    pos = pos - that.wrapperH;
                    page++;
                }
                if (that.maxScrollY % that.wrapperH) that.pagesY[that.pagesY.length] = that.maxScrollY - that.pagesY[that.pagesY.length - 1] + that.pagesY[that.pagesY.length - 1];
            }

            // Prepare the scrollbars
            that._scrollbar('h');
            that._scrollbar('v');

            if (!that.zoomed) {
                that.scroller.style[transitionDuration] = '0';
                that._resetPos(400);
            }
        },

        scrollTo: function(x, y, time, relative) {
            var that = this,
                step = x,
                i, l;

            that.stop();

            if (!step.length) step = [{
                x: x,
                y: y,
                time: time,
                relative: relative
            }];

            for (i = 0, l = step.length; i < l; i++) {
                if (step[i].relative) {
                    step[i].x = that.x - step[i].x;
                    step[i].y = that.y - step[i].y;
                }
                that.steps.push({
                    x: step[i].x,
                    y: step[i].y,
                    time: step[i].time || 0
                });
            }

            that._startAni();
        },

        scrollToElement: function(el, time) {
            var that = this,
                pos;
            el = el.nodeType ? el : that.scroller.querySelector(el);
            if (!el) return;

            pos = that._offset(el);
            pos.left += that.wrapperOffsetLeft;
            pos.top += that.wrapperOffsetTop;

            pos.left = pos.left > 0 ? 0 : pos.left < that.maxScrollX ? that.maxScrollX : pos.left;
            pos.top = pos.top > that.minScrollY ? that.minScrollY : pos.top < that.maxScrollY ? that.maxScrollY : pos.top;
            time = time === undefined ? m.max(m.abs(pos.left) * 2, m.abs(pos.top) * 2) : time;

            that.scrollTo(pos.left, pos.top, time);
        },

        scrollToPage: function(pageX, pageY, time) {
            var that = this,
                x, y;

            time = time === undefined ? 400 : time;

            if (that.options.onScrollStart) that.options.onScrollStart.call(that);

            if (that.options.snap) {
                pageX = pageX == 'next' ? that.currPageX + 1 : pageX == 'prev' ? that.currPageX - 1 : pageX;
                pageY = pageY == 'next' ? that.currPageY + 1 : pageY == 'prev' ? that.currPageY - 1 : pageY;

                pageX = pageX < 0 ? 0 : pageX > that.pagesX.length - 1 ? that.pagesX.length - 1 : pageX;
                pageY = pageY < 0 ? 0 : pageY > that.pagesY.length - 1 ? that.pagesY.length - 1 : pageY;

                that.currPageX = pageX;
                that.currPageY = pageY;
                x = that.pagesX[pageX];
                y = that.pagesY[pageY];
            } else {
                x = -that.wrapperW * pageX;
                y = -that.wrapperH * pageY;
                if (x < that.maxScrollX) x = that.maxScrollX;
                if (y < that.maxScrollY) y = that.maxScrollY;
            }

            that.scrollTo(x, y, time);
        },

        disable: function() {
            this.stop();
            this._resetPos(0);
            this.enabled = false;

            // If disabled after touchstart we make sure that there are no left over events
            this._unbind(MOVE_EV, window);
            this._unbind(END_EV, window);
            this._unbind(CANCEL_EV, window);
        },

        enable: function() {
            this.enabled = true;
        },

        stop: function() {
            if (this.options.useTransition) this._unbind(TRNEND_EV);
            else cancelFrame(this.aniTime);
            this.steps = [];
            this.moved = false;
            this.animating = false;
        },

        zoom: function(x, y, scale, time) {
            var that = this,
                relScale = scale / that.scale;

            if (!that.options.useTransform) return;

            that.zoomed = true;
            time = time === undefined ? 200 : time;
            x = x - that.wrapperOffsetLeft - that.x;
            y = y - that.wrapperOffsetTop - that.y;
            that.x = x - x * relScale + that.x;
            that.y = y - y * relScale + that.y;

            that.scale = scale;
            that.refresh();

            that.x = that.x > 0 ? 0 : that.x < that.maxScrollX ? that.maxScrollX : that.x;
            that.y = that.y > that.minScrollY ? that.minScrollY : that.y < that.maxScrollY ? that.maxScrollY : that.y;

            that.scroller.style[transitionDuration] = time + 'ms';
            that.scroller.style[transform] = 'translate(' + that.x + 'px,' + that.y + 'px) scale(' + scale + ')' + translateZ;
            that.zoomed = false;
        },

        isReady: function() {
            return !this.moved && !this.zoomed && !this.animating;
        }
    };

    function prefixStyle(style) {
        if (vendor === '') return style;

        style = style.charAt(0).toUpperCase() + style.substr(1);
        return vendor + style;
    }

    dummyStyle = null; // for the sake of it

    if (typeof exports !== 'undefined') exports.iScroll = iScroll;
    else window.iScroll = iScroll;

})(window, document);


/*!
 * Socialite v2.0
 * http://socialitejs.com
 * Copyright (c) 2011 David Bushell
 * Dual-licensed under the BSD or MIT licenses: http://socialitejs.com/license.txt
 */
window.Socialite = (function(window, document, undefined) {
    'use strict';

    var uid = 0,
        instances = [],
        networks = {},
        widgets = {},
        rstate = /^($|loaded|complete)/,
        euc = window.encodeURIComponent;

    var socialite = {

        settings: {},

        trim: function(str) {
            return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
        },

        hasClass: function(el, cn) {
            return (' ' + el.className + ' ').indexOf(' ' + cn + ' ') !== -1;
        },

        addClass: function(el, cn) {
            if (!socialite.hasClass(el, cn)) {
                el.className = (el.className === '') ? cn : el.className + ' ' + cn;
            }
        },

        removeClass: function(el, cn) {
            el.className = socialite.trim(' ' + el.className + ' '.replace(' ' + cn + ' ', ' '));
        },

        /**
         * Copy properties of one object to another
         */
        extendObject: function(to, from, overwrite) {
            for (var prop in from) {
                var hasProp = to[prop] !== undefined;
                if (hasProp && typeof from[prop] === 'object') {
                    socialite.extendObject(to[prop], from[prop], overwrite);
                } else if (overwrite || !hasProp) {
                    to[prop] = from[prop];
                }
            }
        },

        /**
         * Return elements with a specific class
         *
         * @param context - containing element to search within
         * @param cn      - class name to search for
         *
         */
        getElements: function(context, cn) {
            // copy to a new array to avoid a live NodeList
            var i = 0,
                el = [],
                gcn = !!context.getElementsByClassName,
                all = gcn ? context.getElementsByClassName(cn) : context.getElementsByTagName('*');
            for (; i < all.length; i++) {
                if (gcn || socialite.hasClass(all[i], cn)) {
                    el.push(all[i]);
                }
            }
            return el;
        },

        /**
         * Return data-* attributes of element as a query string (or object)
         *
         * @param el       - the element
         * @param noprefix - (optional) if true, remove "data-" from attribute names
         * @param nostr    - (optional) if true, return attributes in an object
         *
         */
        getDataAttributes: function(el, noprefix, nostr) {
            var i = 0,
                str = '',
                obj = {},
                attr = el.attributes;
            for (; i < attr.length; i++) {
                var key = attr[i].name,
                    val = attr[i].value;
                if (val.length && key.indexOf('data-') === 0) {
                    if (noprefix) {
                        key = key.substring(5);
                    }
                    if (nostr) {
                        obj[key] = val;
                    } else {
                        str += euc(key) + '=' + euc(val) + '&';
                    }
                }
            }
            return nostr ? obj : str;
        },

        /**
         * Copy data-* attributes from one element to another
         *
         * @param from     - element to copy from
         * @param to       - element to copy to
         * @param noprefix - (optional) if true, remove "data-" from attribute names
         * @param nohyphen - (optional) if true, convert hyphens to underscores in the attribute names
         *
         */
        copyDataAttributes: function(from, to, noprefix, nohyphen) {
            // `nohyphen` was needed for Facebook's <fb:like> elements - remove as no longer used?
            var attr = socialite.getDataAttributes(from, noprefix, true);
            for (var i in attr) {
                to.setAttribute(nohyphen ? i.replace(/-/g, '_') : i, attr[i]);
            }
        },

        /**
         * Create iframe element
         *
         * @param src      - iframe URL (src attribute)
         * @param instance - (optional) socialite instance to activate on iframe load
         *
         */
        createIframe: function(src, instance) {
            // Socialite v2 has slashed the amount of manual iframe creation, we should aim to avoid this entirely
            var iframe = document.createElement('iframe');
            iframe.style.cssText = 'overflow: hidden; border: none;';
            socialite.extendObject(iframe, {
                src: src,
                allowtransparency: 'true',
                frameborder: '0',
                scrolling: 'no'
            }, true);
            if (instance) {
                iframe.onload = iframe.onreadystatechange = function() {
                    if (rstate.test(iframe.readyState || '')) {
                        iframe.onload = iframe.onreadystatechange = null;
                        socialite.activateInstance(instance);
                    }
                };
            }
            return iframe;
        },

        /**
         * Returns true if network script has loaded
         */
        networkReady: function(name) {
            return networks[name] ? networks[name].loaded : undefined;
        },

        /**
         * Append network script to the document
         */
        appendNetwork: function(network) {
            // the activation process is getting a little confusing for some networks
            // it would appear a script load event does not mean its global object exists yet
            // therefore the first call to `activateAll` may have no effect whereas the second call does, e.g. via `window.twttr.ready`

            if (!network || network.appended) {
                return;
            }
            // `network.append` and `network.onload` can cancel progress
            if (typeof network.append === 'function' && network.append(network) === false) {
                network.appended = network.loaded = true;
                socialite.activateAll(network);
                return;
            }

            if (network.script) {
                network.el = document.createElement('script');
                socialite.extendObject(network.el, network.script, true);
                network.el.async = true;
                network.el.onload = network.el.onreadystatechange = function() {
                    if (rstate.test(network.el.readyState || '')) {
                        network.el.onload = network.el.onreadystatechange = null;
                        network.loaded = true;
                        if (typeof network.onload === 'function' && network.onload(network) === false) {
                            return;
                        }
                        socialite.activateAll(network);
                    }
                };
                document.body.appendChild(network.el);
            }
            network.appended = true;
        },

        /**
         * Remove network script from the document
         */
        removeNetwork: function(network) {
            if (!socialite.networkReady(network.name)) {
                return false;
            }
            if (network.el.parentNode) {
                network.el.parentNode.removeChild(network.el);
            }
            return !(network.appended = network.loaded = false);
        },

        /**
         * Remove and re-append network script to the document
         */
        reloadNetwork: function(name) {
            // This is a last-ditch effort for half-baked scripts
            var network = networks[name];
            if (network && socialite.removeNetwork(network)) {
                socialite.appendNetwork(network);
            }
        },

        /**
         * Create new Socialite instance
         *
         * @param el     - parent element that will hold the new instance
         * @param widget - widget the instance belongs to
         *
         */
        createInstance: function(el, widget) {
            var proceed = true,
                instance = {
                    el: el,
                    uid: uid++,
                    widget: widget
                };
            instances.push(instance);
            if (widget.process !== undefined) {
                proceed = (typeof widget.process === 'function') ? widget.process(instance) : false;
            }
            if (proceed) {
                socialite.processInstance(instance);
            }
            instance.el.setAttribute('data-socialite', instance.uid);
            instance.el.className = 'socialite ' + widget.name + ' socialite-instance';
            return instance;
        },

        /**
         * Process a socialite instance to an intermediate state prior to load
         */
        processInstance: function(instance) {
            var el = instance.el;
            instance.el = document.createElement('div');
            instance.el.className = el.className;
            socialite.copyDataAttributes(el, instance.el);
            // stop over-zealous scripts from activating all instances
            if (el.nodeName.toLowerCase() === 'a' && !el.getAttribute('data-default-href')) {
                instance.el.setAttribute('data-default-href', el.getAttribute('href'));
            }
            var parent = el.parentNode;
            parent.insertBefore(instance.el, el);
            parent.removeChild(el);
        },

        /**
         * Activate a socialite instance
         */
        activateInstance: function(instance) {
            if (instance && !instance.loaded) {
                instance.loaded = true;
                if (typeof instance.widget.activate === 'function') {
                    instance.widget.activate(instance);
                }
                socialite.addClass(instance.el, 'socialite-loaded');
                return instance.onload ? instance.onload(instance.el) : null;
            }
        },

        /**
         * Activate all socialite instances belonging to a network
         */
        activateAll: function(network) {
            if (typeof network === 'string') {
                network = networks[network];
            }
            for (var i = 0; i < instances.length; i++) {
                var instance = instances[i];
                if (instance.init && instance.widget.network === network) {
                    socialite.activateInstance(instance);
                }
            }
        },

        /**
         * Load socialite instances
         *
         * @param context - (optional) containing element to search within
         * @param el      - (optional) individual or an array of elements to load
         * @param w       - (optional) widget name
         * @param onload  - (optional) function to call after each socialite instance has loaded
         * @param process - (optional) process but don't load network (if true)
         *
         */
        load: function(context, el, w, onload, process) {
            // use document as context if unspecified
            context = (context && typeof context === 'object' && context.nodeType === 1) ? context : document;

            // if no elements search within the context and recurse
            if (!el || typeof el !== 'object') {
                socialite.load(context, socialite.getElements(context, 'socialite'), w, onload, process);
                return;
            }

            var i;

            // if array of elements load each one individually
            if (/Array/.test(Object.prototype.toString.call(el))) {
                for (i = 0; i < el.length; i++) {
                    socialite.load(context, el[i], w, onload, process);
                }
                return;
            }

            // nothing was found...
            if (el.nodeType !== 1) {
                return;
            }

            // if widget name not specified search within the element classes
            if (!w || !widgets[w]) {
                w = null;
                var classes = el.className.split(' ');
                for (i = 0; i < classes.length; i++) {
                    if (widgets[classes[i]]) {
                        w = classes[i];
                        break;
                    }
                }
                if (!w) {
                    return;
                }
            }

            // find or create the Socialite instance
            var instance,
                widget = widgets[w],
                sid = parseInt(el.getAttribute('data-socialite'), 10);
            if (!isNaN(sid)) {
                for (i = 0; i < instances.length; i++) {
                    if (instances[i].uid === sid) {
                        instance = instances[i];
                        break;
                    }
                }
            } else {
                instance = socialite.createInstance(el, widget);
            }

            // return if just processing (or no instance found)
            if (process || !instance) {
                return;
            }

            // initialise the instance
            if (!instance.init) {
                instance.init = true;
                instance.onload = (typeof onload === 'function') ? onload : null;
                widget.init(instance);
            }

            // append the parent network (all instances will be activated onload)
            // or activate immediately if network has already loaded
            if (!widget.network.appended) {
                socialite.appendNetwork(widget.network);
            } else {
                if (socialite.networkReady(widget.network.name)) {
                    socialite.activateInstance(instance);
                }
            }
        },

        /**
         * Load a single element
         *
         * @param el     - an individual element
         * @param w      - (optional) widget for this socialite instance
         * @param onload - (optional) function to call once each instance has loaded
         *
         */
        activate: function(el, w, onload) {
            // skip the first few steps
            window.Socialite.load(null, el, w, onload);
        },

        /**
         * Process elements to an intermediate state prior to load
         *
         * @param context - containing element to search within
         * @param el      - (optional) individual or an array of elements to load
         * @param w       - (optional) widget name
         *
         */
        process: function(context, el, w) {
            // stop before widget initialises instance
            window.Socialite.load(context, el, w, null, true);
        },

        /**
         * Add a new social network
         *
         * @param name   - unique name for network
         * @param params - additional data and callbacks
         *
         */
        network: function(n, params) {
            networks[n] = {
                name: n,
                el: null,
                appended: false,
                loaded: false,
                widgets: {}
            };
            if (params) {
                socialite.extendObject(networks[n], params);
            }
        },

        /**
         * Add a new social widget
         *
         * @param name   - name of owner network
         * @param w      - unique name for widget
         * @param params - additional data and callbacks
         *
         */
        widget: function(n, w, params) {
            params.name = n + '-' + w;
            if (!networks[n] || widgets[params.name]) {
                return;
            }
            params.network = networks[n];
            networks[n].widgets[w] = widgets[params.name] = params;
        },

        /**
         * Change the default Socialite settings for each network
         */
        setup: function(params) {
            socialite.extendObject(socialite.settings, params, true);
        }

    };

    return socialite;

})(window, window.document);

/**
 * Socialite Extensions - Pick 'n' Mix!
 */
(function(window, document, Socialite, undefined) {

    // default to the Queen's English
    Socialite.setup({
        facebook: {
            lang: 'en_GB',
            appId: null
        },
        twitter: {
            lang: 'en'
        },
        googleplus: {
            lang: 'en-GB'
        }
    });


    // Facebook
    // http://developers.facebook.com/docs/reference/plugins/like/
    // http://developers.facebook.com/docs/reference/javascript/FB.init/

    Socialite.network('facebook', {
        script: {
            src: '//connect.facebook.net/{{language}}/all.js',
            id: 'facebook-jssdk'
        },
        append: function(network) {
            var fb = document.createElement('div'),
                settings = Socialite.settings.facebook,
                events = {
                    onlike: 'edge.create',
                    onunlike: 'edge.remove',
                    onsend: 'message.send'
                };
            fb.id = 'fb-root';
            document.body.appendChild(fb);
            network.script.src = network.script.src.replace('{{language}}', settings.lang);
            window.fbAsyncInit = function() {
                window.FB.init({
                    appId: settings.appId,
                    xfbml: true
                });
                for (var e in events) {
                    if (typeof settings[e] === 'function') {
                        window.FB.Event.subscribe(events[e], settings[e]);
                    }
                }
            };
        }
    });

    var facebookInit = function(instance) {
        var el = document.createElement('div');
        el.className = instance.widget.fbtype;
        Socialite.copyDataAttributes(instance.el, el);
        instance.el.appendChild(el);
        if (window.FB && window.FB.XFBML) {
            window.FB.XFBML.parse(instance.el);
        }
    };

    Socialite.widget('facebook', 'like', {
        init: facebookInit,
        fbtype: 'fb-like'
    });
    Socialite.widget('facebook', 'share', {
        init: facebookInit,
        fbtype: 'fb-share-button'
    });


    // Twitter
    // https://dev.twitter.com/docs/tweet-button/
    // https://dev.twitter.com/docs/intents/events/
    // https://developers.google.com/analytics/devguides/collection/gajs/gaTrackingSocial#twitter

    Socialite.network('twitter', {
        script: {
            src: '//platform.twitter.com/widgets.js',
            id: 'twitter-wjs',
            charset: 'utf-8'
        },
        append: function() {
            var notwttr = (typeof window.twttr !== 'object'),
                settings = Socialite.settings.twitter,
                events = ['click', 'tweet', 'retweet', 'favorite', 'follow'];
            if (notwttr) {
                window.twttr = (t = {
                    _e: [],
                    ready: function(f) {
                        t._e.push(f);
                    }
                });
            }
            window.twttr.ready(function(twttr) {
                for (var i = 0; i < events.length; i++) {
                    var e = events[i];
                    if (typeof settings['on' + e] === 'function') {
                        twttr.events.bind(e, settings['on' + e]);
                    }
                }
                Socialite.activateAll('twitter');
            });
            return notwttr;
        }
    });

    var twitterInit = function(instance) {
        var el = document.createElement('a');
        el.className = instance.widget.name + '-button';
        Socialite.copyDataAttributes(instance.el, el);
        el.setAttribute('href', instance.el.getAttribute('data-default-href'));
        el.setAttribute('data-lang', instance.el.getAttribute('data-lang') || Socialite.settings.twitter.lang);
        instance.el.appendChild(el);
    };

    var twitterActivate = function(instance) {
        if (window.twttr && typeof window.twttr.widgets === 'object' && typeof window.twttr.widgets.load === 'function') {
            window.twttr.widgets.load();
        }
    };

    Socialite.widget('twitter', 'share', {
        init: twitterInit,
        activate: twitterActivate
    });
    Socialite.widget('twitter', 'follow', {
        init: twitterInit,
        activate: twitterActivate
    });
    Socialite.widget('twitter', 'hashtag', {
        init: twitterInit,
        activate: twitterActivate
    });
    Socialite.widget('twitter', 'mention', {
        init: twitterInit,
        activate: twitterActivate
    });

    Socialite.widget('twitter', 'embed', {
        process: function(instance) {
            instance.innerEl = instance.el;
            if (!instance.innerEl.getAttribute('data-lang')) {
                instance.innerEl.setAttribute('data-lang', Socialite.settings.twitter.lang);
            }
            instance.el = document.createElement('div');
            instance.el.className = instance.innerEl.className;
            instance.innerEl.className = '';
            instance.innerEl.parentNode.insertBefore(instance.el, instance.innerEl);
            instance.el.appendChild(instance.innerEl);
        },
        init: function(instance) {
            instance.innerEl.className = 'twitter-tweet';
        },
        activate: twitterActivate
    });


    // Google+
    // https://developers.google.com/+/plugins/+1button/
    // Google does not support IE7

    Socialite.network('googleplus', {
        script: {
            src: '//apis.google.com/js/plusone.js'
        },
        append: function(network) {
            if (window.gapi) {
                return false;
            }
            window.___gcfg = {
                lang: Socialite.settings.googleplus.lang,
                parsetags: 'explicit'
            };
        }
    });

    var googleplusInit = function(instance) {
        var el = document.createElement('div');
        el.className = 'g-' + instance.widget.gtype;
        Socialite.copyDataAttributes(instance.el, el);
        instance.el.appendChild(el);
        instance.gplusEl = el;
    };

    var googleplusEvent = function(instance, callback) {
        return (typeof callback !== 'function') ? null : function(data) {
            callback(instance.el, data);
        };
    };

    var googleplusActivate = function(instance) {
        var type = instance.widget.gtype;
        if (window.gapi && window.gapi[type]) {
            var settings = Socialite.settings.googleplus,
                params = Socialite.getDataAttributes(instance.el, true, true),
                events = ['onstartinteraction', 'onendinteraction', 'callback'];
            for (var i = 0; i < events.length; i++) {
                params[events[i]] = googleplusEvent(instance, settings[events[i]]);
            }
            window.gapi[type].render(instance.gplusEl, params);
        }
    };

    Socialite.widget('googleplus', 'one', {
        init: googleplusInit,
        activate: googleplusActivate,
        gtype: 'plusone'
    });
    Socialite.widget('googleplus', 'share', {
        init: googleplusInit,
        activate: googleplusActivate,
        gtype: 'plus'
    });
    Socialite.widget('googleplus', 'badge', {
        init: googleplusInit,
        activate: googleplusActivate,
        gtype: 'plus'
    });
    Socialite.widget('googleplus', 'follow', {
        init: googleplusInit,
        activate: googleplusActivate,
        gtype: 'follow'
    });

    // LinkedIn
    // http://developer.linkedin.com/plugins/share-button/

    Socialite.network('linkedin', {
        script: {
            src: '//platform.linkedin.com/in.js'
        }
    });

    var linkedinInit = function(instance) {
        var el = document.createElement('script');
        el.type = 'IN/' + instance.widget.intype;
        Socialite.copyDataAttributes(instance.el, el);
        instance.el.appendChild(el);
        if (typeof window.IN === 'object' && typeof window.IN.parse === 'function') {
            window.IN.parse(instance.el);
            Socialite.activateInstance(instance);
        }
    };

    Socialite.widget('linkedin', 'share', {
        init: linkedinInit,
        intype: 'Share'
    });
    Socialite.widget('linkedin', 'recommend', {
        init: linkedinInit,
        intype: 'RecommendProduct'
    });
    Socialite.widget('linkedin', 'follow', {
        init: linkedinInit,
        intype: 'FollowCompany'
    });

})(window, window.document, window.Socialite);

/**
 * Execute any queued functions (don't enqueue before the document has loaded!)
 */
(function() {
    var s = window._socialite;
    if (/Array/.test(Object.prototype.toString.call(s))) {
        for (var i = 0, len = s.length; i < len; i++) {
            if (typeof s[i] === 'function') {
                s[i]();
            }
        }
    }
})();


/**
 * jQuery DFP v1.1.9
 * http://github.com/coop182/jquery.dfp.js
 *
 * Copyright 2014 Matt Cooper
 * Released under the MIT license
 */
(function($, window, undefined) {

    'use strict';

    var

    // Save Scope
        dfpScript = this,

        // DFP account ID
        dfpID = '',

        // Init counters
        count = 0,
        uid = 0,
        rendered = 0,

        // Default DFP selector
        dfpSelector = '.adunit',

        // DFP options object
        dfpOptions = {},

        // Keep track of if we've already tried to load gpt.js before
        dfpIsLoaded = false,

        // Collection of ads
        $adCollection,

        // Store adunit on div as:
        storeAs = 'googleAdUnit',

        /**
         * Init function sets required params and loads Google's DFP script
         * @param  String id       The DFP account ID
         * @param  String selector The adunit selector
         * @param  Object options  Custom options to apply
         */
        init = function(id, selector, options) {

            // Reset counters on each call
            count = 0;
            rendered = 0;

            dfpID = id;
            $adCollection = $(selector);

            dfpLoader();
            setOptions(options);

            $(function() {
                createAds();
                displayAds();
            });

        },

        /**
         * Set the options for DFP
         * @param Object options Custom options to apply
         */
        setOptions = function(options) {

            // Set default options
            dfpOptions = {
                setTargeting: {},
                setCategoryExclusion: '',
                setLocation: '',
                enableSingleRequest: true,
                collapseEmptyDivs: 'original',
                refreshExisting: true,
                disablePublisherConsole: false,
                disableInitialLoad: false,
                noFetch: false,
                namespace: undefined,
                sizeMapping: {}
            };

            if (typeof options.setUrlTargeting === 'undefined' || options.setUrlTargeting) {
                // Get URL Targeting
                var urlTargeting = getUrlTargeting(options.url);
                $.extend(true, dfpOptions.setTargeting, {
                    inURL: urlTargeting.inURL,
                    URLIs: urlTargeting.URLIs,
                    Query: urlTargeting.Query,
                    Domain: urlTargeting.Domain
                });
            }

            // Merge options objects
            $.extend(true, dfpOptions, options);

            // If a custom googletag is specified, use it.
            if (dfpOptions.googletag) {
                window.googletag.cmd.push(function() {
                    $.extend(true, window.googletag, dfpOptions.googletag);
                });
            }
        },

        /**
         * Find and create all Ads
         * @return Array an array of ad units that have been created.
         */
        createAds = function() {

            // Loops through on page Ad units and gets ads for them.
            $adCollection.each(function() {

                var $adUnit = $(this);

                count++;

                // adUnit name
                var adUnitName = getName($adUnit);

                // adUnit id - this will use an existing id or an auto generated one.
                var adUnitID = getID($adUnit, adUnitName);

                // get dimensions of the adUnit
                var dimensions = getDimensions($adUnit);

                // set existing content
                $adUnit.data('existingContent', $adUnit.html());

                // wipe html clean ready for ad and set the default display class.
                $adUnit.html('').addClass('display-none');

                // Push commands to DFP to create ads
                window.googletag.cmd.push(function() {

                    var googleAdUnit,
                        $adUnitData = $adUnit.data(storeAs);

                    if ($adUnitData) {

                        // Get existing ad unit
                        googleAdUnit = $adUnitData;

                    } else {

                        // Create the ad - out of page or normal
                        if ($adUnit.data('outofpage')) {
                            googleAdUnit = window.googletag.defineOutOfPageSlot('/' + dfpID + '/' + adUnitName, adUnitID).addService(window.googletag.pubads());
                        } else {
                            if ($adUnit.data('companion')) {
                                googleAdUnit = window.googletag.defineSlot('/' + dfpID + '/' + adUnitName, dimensions, adUnitID)
                                    .addService(window.googletag.companionAds()).addService(window.googletag.pubads());
                            } else {
                                googleAdUnit = window.googletag.defineSlot('/' + dfpID + '/' + adUnitName, dimensions, adUnitID)
                                    .addService(window.googletag.pubads());
                            }
                        }

                    }

                    // Sets custom targeting for just THIS ad unit if it has been specified
                    var targeting = $adUnit.data('targeting');
                    if (targeting) {
                        $.each(targeting, function(k, v) {
                            googleAdUnit.setTargeting(k, v);
                        });
                    }

                    // Sets custom exclusions for just THIS ad unit if it has been specified
                    var exclusions = $adUnit.data('exclusions');
                    if (exclusions) {
                        var exclusionsGroup = exclusions.split(',');
                        var valueTrimmed;
                        $.each(exclusionsGroup, function(k, v) {
                            valueTrimmed = $.trim(v);
                            if (valueTrimmed.length > 0) {
                                googleAdUnit.setCategoryExclusion(valueTrimmed);
                            }
                        });
                    }

                    // Sets responsive size mapping for just THIS ad unit if it has been specified
                    var mapping = $adUnit.data('size-mapping');
                    if (mapping && dfpOptions.sizeMapping[mapping]) {
                        // Convert verbose to DFP format
                        var map = window.googletag.sizeMapping();
                        $.each(dfpOptions.sizeMapping[mapping], function(k, v) {
                            map.addSize(v.browser, v.ad_sizes);
                        });
                        googleAdUnit.defineSizeMapping(map.build());
                    }

                    // Store googleAdUnit reference
                    $adUnit.data(storeAs, googleAdUnit);

                    // Allow altering of the ad slot before ad load
                    if (typeof dfpOptions.beforeEachAdLoaded === 'function') {
                        dfpOptions.beforeEachAdLoaded.call(this, $adUnit);
                    }
                });

            });

            // Push DFP config options
            window.googletag.cmd.push(function() {

                if (dfpOptions.enableSingleRequest) {
                    window.googletag.pubads().enableSingleRequest();
                }
                $.each(dfpOptions.setTargeting, function(k, v) {
                    window.googletag.pubads().setTargeting(k, v);
                });

                if (typeof dfpOptions.setLocation === 'object') {
                    if (typeof dfpOptions.setLocation.latitude === 'number' && typeof dfpOptions.setLocation.longitude === 'number' && typeof dfpOptions.setLocation.precision === 'number') {
                        window.googletag.pubads().setLocation(dfpOptions.setLocation.latitude, dfpOptions.setLocation.longitude, dfpOptions.setLocation.precision);
                    } else if (typeof dfpOptions.setLocation.latitude === 'number' && typeof dfpOptions.setLocation.longitude === 'number') {
                        window.googletag.pubads().setLocation(dfpOptions.setLocation.latitude, dfpOptions.setLocation.longitude);
                    }
                }

                if (dfpOptions.setCategoryExclusion.length > 0) {
                    var exclusionsGroup = dfpOptions.setCategoryExclusion.split(',');
                    var valueTrimmed;
                    $.each(exclusionsGroup, function(k, v) {
                        valueTrimmed = $.trim(v);
                        if (valueTrimmed.length > 0) {
                            window.googletag.pubads().setCategoryExclusion(valueTrimmed);
                        }
                    });
                }
                if (dfpOptions.collapseEmptyDivs) {
                    window.googletag.pubads().collapseEmptyDivs();
                }

                if (dfpOptions.disablePublisherConsole) {
                    window.googletag.pubads().disablePublisherConsole();
                }
                if (dfpOptions.companionAds) {
                    window.googletag.companionAds().setRefreshUnfilledSlots(true);

                    if (!dfpOptions.disableInitialLoad) {
                        window.googletag.pubads().enableVideoAds();
                    }
                }
                if (dfpOptions.disableInitialLoad) {
                    window.googletag.pubads().disableInitialLoad();
                }

                if (dfpOptions.noFetch) {
                    window.googletag.pubads().noFetch();
                }

                // Setup event listener to listen for renderEnded event and fire callbacks.
                window.googletag.pubads().addEventListener('slotRenderEnded', function(event) {

                    rendered++;

                    var $adUnit = $('#' + event.slot.getSlotId().getDomId());

                    var display = event.isEmpty ? 'none' : 'block';

                    // if the div has been collapsed but there was existing content expand the
                    // div and reinsert the existing content.
                    var $existingContent = $adUnit.data('existingContent');
                    if (display === 'none' && $.trim($existingContent).length > 0 && dfpOptions.collapseEmptyDivs === 'original') {
                        $adUnit.show().html($existingContent);
                        display = 'block display-original';
                    }

                    $adUnit.removeClass('display-none').addClass('display-' + display);

                    // Excute afterEachAdLoaded callback if provided
                    if (typeof dfpOptions.afterEachAdLoaded === 'function') {
                        dfpOptions.afterEachAdLoaded.call(this, $adUnit, event);
                    }

                    // Excute afterAllAdsLoaded callback if provided
                    if (typeof dfpOptions.afterAllAdsLoaded === 'function' && rendered === count) {
                        dfpOptions.afterAllAdsLoaded.call(this, $adCollection);
                    }

                });

                window.googletag.enableServices();

            });

        },

        /**
         * Display all created Ads
         */
        displayAds = function() {

            // Display each ad
            $adCollection.each(function() {

                var $adUnit = $(this),
                    $adUnitData = $adUnit.data(storeAs);

                if (dfpOptions.refreshExisting && $adUnitData && $adUnit.hasClass('display-block')) {

                    window.googletag.cmd.push(function() {
                        window.googletag.pubads().refresh([$adUnitData]);
                    });

                } else {

                    window.googletag.cmd.push(function() {
                        window.googletag.display($adUnit.attr('id'));
                    });

                }

            });

        },

        /**
         * Create an array of paths so that we can target DFP ads to Page URI's
         * @return Array an array of URL parts that can be targeted.
         */
        getUrlTargeting = function(url) {

            // Get the url and parse it to its component parts using regex from RFC2396 Appendix-B (https://tools.ietf.org/html/rfc2396#appendix-B)
            var urlMatches = (url || window.location.toString()).match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/);
            var parsedAuthority = urlMatches[4] || '';
            var parsedPath = (urlMatches[5] || '').replace(/\/$/, '');
            var parsedQuery = urlMatches[7] || '';

            var patt = new RegExp('\/([^\/]*)', 'ig'),
                pathsMatches = parsedPath.match(patt),
                targetPaths = ['/'],
                longestpath = '';

            if (pathsMatches && parsedPath !== '/') {
                var target = '',
                    size = pathsMatches.length;
                if (size > 0) {
                    for (var i = 0; i < size; i++) {
                        target = pathsMatches[i];
                        targetPaths.push(target);
                        for (var j = i + 1; j < size; j++) {
                            target += pathsMatches[j];
                            targetPaths.push(target);
                        }
                        if (i === 0) {
                            targetPaths.splice(-1, 1);
                            longestpath = target;
                        }
                    }
                }
                targetPaths.push(longestpath);
            }

            targetPaths = targetPaths.reverse();

            // Get the query params for targeting against
            var params = parsedQuery.replace(/\=/ig, ':').split('&');

            return {
                Domain: parsedAuthority,
                inURL: targetPaths,
                URLIs: targetPaths[0],
                Query: params
            };

        },

        /**
         * Get the id of the adUnit div or generate a unique one.
         * @param  Object $adUnit     The adunit to work with
         * @param  String adUnitName The name of the adunit
         * @return String             The ID of the adunit or a unique autogenerated ID
         */
        getID = function($adUnit, adUnitName) {

            uid++;
            return $adUnit.attr('id') || $adUnit.attr('id', adUnitName.replace(/[^A-z0-9]/g, '_') + '-auto-gen-id-' + uid).attr('id');

        },

        /**
         * Get the name of the Ad unit, either use the div id or
         * check for the optional attribute data-adunit
         * @param  Object $adUnit The adunit to work with
         * @return String        The name of the adunit, will be the same as inside DFP
         */
        getName = function($adUnit) {

            var adUnitName = $adUnit.data('adunit') || dfpOptions.namespace || $adUnit.attr('id') || '';
            if (typeof dfpOptions.alterAdUnitName === 'function') {
                adUnitName = dfpOptions.alterAdUnitName.call(this, adUnitName, $adUnit);
            }
            return adUnitName;

        },

        /**
         * Get the dimensions of the ad unit using the container div dimensions or
         * check for the optional attribute data-dimensions
         * @param  Object $adUnit The adunit to work with
         * @return Array         The dimensions of the adunit (width, height)
         */
        getDimensions = function($adUnit) {

            var dimensions = [],
                dimensionsData = $adUnit.data('dimensions');

            // Check if data-dimensions are specified. If they aren't, use the dimensions of the ad unit div.
            if (dimensionsData) {

                var dimensionGroups = dimensionsData.split(',');

                $.each(dimensionGroups, function(k, v) {

                    var dimensionSet = v.split('x');
                    dimensions.push([parseInt(dimensionSet[0], 10), parseInt(dimensionSet[1], 10)]);

                });

            } else {

                dimensions.push([$adUnit.width(), $adUnit.height()]);

            }

            return dimensions;

        },

        /**
         * Call the google DFP script - there is a little bit of error detection in here to detect
         * if the dfp script has failed to load either through an error or it being blocked by an ad
         * blocker... if it does not load we execute a dummy script to replace the real DFP.
         */
        dfpLoader = function() {

            // make sure we don't load gpt.js multiple times
            dfpIsLoaded = dfpIsLoaded || $('script[src*="googletagservices.com/tag/js/gpt.js"]').length;
            if (dfpIsLoaded) {
                return;
            }

            window.googletag = window.googletag || {};
            window.googletag.cmd = window.googletag.cmd || [];

            var gads = document.createElement('script');
            gads.async = true;
            gads.type = 'text/javascript';

            // Adblock blocks the load of Ad scripts... so we check for that
            gads.onerror = function() {
                dfpBlocked();
            };

            var useSSL = 'https:' === document.location.protocol;
            gads.src = (useSSL ? 'https:' : 'http:') +
                '//www.googletagservices.com/tag/js/gpt.js';
            var node = document.getElementsByTagName('script')[0];
            node.parentNode.insertBefore(gads, node);

            // Adblock plus seems to hide blocked scripts... so we check for that
            if (gads.style.display === 'none') {
                dfpBlocked();
            }

        },

        /**
         * This function gets called if DFP has been blocked by an adblocker
         * it implements a dummy version of the dfp object and allows the script to excute its callbacks
         * regardless of whether DFP is actually loaded or not... it is basically only useful for situations
         * where you are laying DFP over existing content and need to init things like slide shows after the loading
         * is completed.
         */
        dfpBlocked = function() {

            // Get the stored dfp commands
            var commands = window.googletag.cmd;

            // SetTimeout is a bit dirty but the script does not execute in the correct order without it
            setTimeout(function() {

                var _defineSlot = function(name, dimensions, id, oop) {
                    window.googletag.ads.push(id);
                    window.googletag.ads[id] = {
                        renderEnded: function() {},
                        addService: function() {
                            return this;
                        }
                    };
                    return window.googletag.ads[id];
                };

                // overwrite the dfp object - replacing the command array with a function and defining missing functions
                window.googletag = {
                    cmd: {
                        push: function(callback) {
                            callback.call(dfpScript);
                        }
                    },
                    ads: [],
                    pubads: function() {
                        return this;
                    },
                    noFetch: function() {
                        return this;
                    },
                    disableInitialLoad: function() {
                        return this;
                    },
                    disablePublisherConsole: function() {
                        return this;
                    },
                    enableSingleRequest: function() {
                        return this;
                    },
                    setTargeting: function() {
                        return this;
                    },
                    collapseEmptyDivs: function() {
                        return this;
                    },
                    enableServices: function() {
                        return this;
                    },
                    defineSlot: function(name, dimensions, id) {
                        return _defineSlot(name, dimensions, id, false);
                    },
                    defineOutOfPageSlot: function(name, id) {
                        return _defineSlot(name, [], id, true);
                    },
                    display: function(id) {
                        window.googletag.ads[id].renderEnded.call(dfpScript);
                        return this;
                    }

                };

                // Execute any stored commands
                $.each(commands, function(k, v) {
                    window.googletag.cmd.push(v);
                });

            }, 50);

        };

    /**
     * Make plugin UMD compatible
     * Uses CommonJS, AMD or browser globals to create plugin.
     */
    (function(factory) {
        if (typeof define === 'function' && define.amd) {
            // AMD. Register as an anonymous module.
            define(['jquery'], factory);
        } else if (typeof exports === 'object') {
            // Node/CommonJS
            factory(require('jquery'));
        } else {
            // Browser globals
            factory($);
        }
    }(function($) {

        /**
         * Add function to the jQuery / Zepto / tire namespace
         * @param  String id      (Optional) The DFP account ID
         * @param  Object options (Optional) Custom options to apply
         */
        $.dfp = $.fn.dfp = function(id, options) {

            options = options || {};

            if (id === undefined) {
                id = dfpID;
            }

            if (typeof id === 'object') {
                options = id;
                id = options.dfpID || dfpID;
            }

            var selector = this;

            if (typeof this === 'function') {
                selector = dfpSelector;
            }

            init(id, selector, options);

            return this;

        };

    }));

})(window.jQuery || window.Zepto || window.tire, window);


// jQuery HC-Sticky
// =============
// Version: 1.2.43
// Copyright: Some Web Media
// Author: Some Web Guy
// Author URL: http://twitter.com/some_web_guy
// Website: http://someweblog.com/
// Plugin URL: https://github.com/somewebmedia/hc-sticky
// License: Released under the MIT License www.opensource.org/licenses/mit-license.php
// Description: Cross-browser jQuery plugin that makes any element attached to the page and always visible while you scroll.

(function($, window, undefined) {
    "use strict";

    // console.log shortcut
    var log = function(t) {
        console.log(t)
    };

    var $window = $(window),
        document = window.document,
        $document = $(document);

    // detect IE version
    var ie = (function() {
        var undef, v = 3,
            div = document.createElement('div'),
            all = div.getElementsByTagName('i');
        while (div.innerHTML = '<!--[if gt IE ' + (++v) + ']><i></i><![endif]-->', all[0]) {};
        return v > 4 ? v : undef
    })();

    /*----------------------------------------------------
						Global functions
	----------------------------------------------------*/

    // check for scroll direction and speed
    var getScroll = function() {
        var pageXOffset = window.pageXOffset !== undefined ? window.pageXOffset : (document.compatMode == "CSS1Compat" ? window.document.documentElement.scrollLeft : window.document.body.scrollLeft),
            pageYOffset = window.pageYOffset !== undefined ? window.pageYOffset : (document.compatMode == "CSS1Compat" ? window.document.documentElement.scrollTop : window.document.body.scrollTop);

        if (typeof getScroll.x == 'undefined') {
            getScroll.x = pageXOffset;
            getScroll.y = pageYOffset;
        }
        if (typeof getScroll.distanceX == 'undefined') {
            getScroll.distanceX = pageXOffset;
            getScroll.distanceY = pageYOffset;
        } else {
            getScroll.distanceX = pageXOffset - getScroll.x;
            getScroll.distanceY = pageYOffset - getScroll.y;
        }

        var diffX = getScroll.x - pageXOffset,
            diffY = getScroll.y - pageYOffset;

        getScroll.direction = diffX < 0 ? 'right' :
            diffX > 0 ? 'left' :
            diffY <= 0 ? 'down' :
            diffY > 0 ? 'up' : 'first';

        getScroll.x = pageXOffset;
        getScroll.y = pageYOffset;
    };
    $window.on('scroll', getScroll);


    // little original style plugin
    $.fn.style = function(style) {
        if (!style) return null;

        var $this = $(this),
            value;

        // clone element
        var $clone = $this.clone().css('display', 'none');
        // randomize the name of cloned radio buttons, otherwise selections get screwed
        $clone.find('input:radio').attr('name', 'copy-' + Math.floor((Math.random() * 100) + 1));
        // insert clone to DOM
        $this.after($clone);

        var getStyle = function(el, style) {
            var val;
            if (el.currentStyle) {
                // replace dashes with capitalized letter, e.g. padding-left to paddingLeft
                val = el.currentStyle[style.replace(/-\w/g, function(s) {
                    return s.toUpperCase().replace('-', '')
                })];
            } else if (window.getComputedStyle) {
                val = document.defaultView.getComputedStyle(el, null).getPropertyValue(style);
            }
            // check for margin:auto
            val = (/margin/g.test(style)) ? ((parseInt(val) === $this[0].offsetLeft) ? val : 'auto') : val;
            return val;
        };

        if (typeof style == 'string') {
            value = getStyle($clone[0], style);
        } else {
            value = {};
            $.each(style, function(i, s) {
                value[s] = getStyle($clone[0], s);
            });
        }

        // destroy clone
        $clone.remove();

        return value || null;
    };


    /*----------------------------------------------------
						jQuery plugin
	----------------------------------------------------*/

    $.fn.extend({

        hcSticky: function(options) {

            // check if selected element exist in DOM, user doesn't have to worry about that
            if (this.length == 0) return this;

            this.pluginOptions('hcSticky', {
                top: 0,
                bottom: 0,
                bottomEnd: 0,
                innerTop: 0,
                innerSticker: null,
                className: 'sticky',
                wrapperClassName: 'wrapper-sticky',
                stickTo: null,
                responsive: true,
                followScroll: true,
                offResolutions: null,
                onStart: $.noop,
                onStop: $.noop,
                on: true,
                fn: null // used only by the plugin
            }, options || {}, {
                reinit: function() {
                    // just call itself again
                    $(this).hcSticky();
                },
                stop: function() {
                    $(this).pluginOptions('hcSticky', {
                        on: false
                    }).each(function() {
                        var $this = $(this),
                            options = $this.pluginOptions('hcSticky'),
                            $wrapper = $this.parent('.' + options.wrapperClassName);

                        // set current position
                        var top = $this.offset().top - $wrapper.offset().top;
                        $this.css({
                            position: 'absolute',
                            top: top,
                            bottom: 'auto',
                            left: 'auto',
                            right: 'auto'
                        }).removeClass(options.className);
                    });
                },
                off: function() {
                    $(this).pluginOptions('hcSticky', {
                        on: false
                    }).each(function() {
                        var $this = $(this),
                            options = $this.pluginOptions('hcSticky'),
                            $wrapper = $this.parent('.' + options.wrapperClassName);

                        // clear position
                        $this.css({
                            position: 'relative',
                            top: 'auto',
                            bottom: 'auto',
                            left: 'auto',
                            right: 'auto'
                        }).removeClass(options.className);

                        $wrapper.css('height', 'auto');
                    });
                },
                on: function() {
                    $(this).each(function() {
                        $(this).pluginOptions('hcSticky', {
                            on: true,
                            remember: {
                                offsetTop: $window.scrollTop()
                            }
                        }).hcSticky();
                    });
                },
                destroy: function() {
                    var $this = $(this),
                        options = $this.pluginOptions('hcSticky'),
                        $wrapper = $this.parent('.' + options.wrapperClassName);

                    // reset position to original
                    $this.removeData('hcStickyInit').css({
                        position: $wrapper.css('position'),
                        top: $wrapper.css('top'),
                        bottom: $wrapper.css('bottom'),
                        left: $wrapper.css('left'),
                        right: $wrapper.css('right')
                    }).removeClass(options.className);

                    // remove events
                    $window.off('resize', options.fn.resize).off('scroll', options.fn.scroll);

                    // destroy wrapper
                    $this.unwrap();
                }
            });

            // on/off settings
            if (options && typeof options.on != 'undefined') {
                if (options.on) {
                    this.hcSticky('on');
                } else {
                    this.hcSticky('off');
                }
            }

            // stop on commands
            if (typeof options == 'string') return this;

            // do our thing
            return this.each(function() {

                var $this = $(this),
                    options = $this.pluginOptions('hcSticky');

                var $wrapper = (function() { // wrapper exists
                    var $this_wrapper = $this.parent('.' + options.wrapperClassName);
                    if ($this_wrapper.length > 0) {
                        $this_wrapper.css({
                            'height': $this.outerHeight(true),
                            'width': (function() {
                                // check if wrapper already has width in %
                                var width = $this_wrapper.style('width');
                                if (width.indexOf('%') >= 0 || width == 'auto') {
                                    if ($this.css('box-sizing') == 'border-box' || $this.css('-moz-box-sizing') == 'border-box') {
                                        $this.css('width', $this_wrapper.width());
                                    } else {
                                        $this.css('width', $this_wrapper.width() - parseInt($this.css('padding-left') - parseInt($this.css('padding-right'))));
                                    }
                                    return width;
                                } else {
                                    return $this.outerWidth(true);
                                }
                            })()
                        });
                        return $this_wrapper;
                    } else {
                        return false;
                    }
                })() || (function() { // wrapper doesn't exist

                    var this_css = $this.style(['width', 'margin-left', 'left', 'right', 'top', 'bottom', 'float', 'display']);
                    var display = $this.css('display');

                    var $this_wrapper = $('<div>', {
                        'class': options.wrapperClassName
                    }).css({
                        'display': display,
                        'height': $this.outerHeight(true),
                        'width': (function() {
                            if (this_css['width'].indexOf('%') >= 0 || (this_css['width'] == 'auto' && display != 'inline-block' && display != 'inline')) { // check if element has width in %
                                $this.css('width', parseFloat($this.css('width')));
                                return this_css['width'];
                            } else if (this_css['width'] == 'auto' && (display == 'inline-block' || display == 'inline')) {
                                return $this.width();
                            } else {
                                // check if margin is set to 'auto'
                                return (this_css['margin-left'] == 'auto') ? $this.outerWidth() : $this.outerWidth(true);
                            }
                        })(),
                        'margin': (this_css['margin-left']) ? 'auto' : null,
                        'position': (function() {
                            var position = $this.css('position');
                            return position == 'static' ? 'relative' : position;
                        })(),
                        'float': this_css['float'] || null,
                        'left': this_css['left'],
                        'right': this_css['right'],
                        'top': this_css['top'],
                        'bottom': this_css['bottom'],
                        'vertical-align': 'top'
                    });

                    $this.wrap($this_wrapper);

                    // ie7 inline-block fix
                    if (ie === 7) {
                        if ($('head').find('style#hcsticky-iefix').length === 0) {
                            $('<style id="hcsticky-iefix">.' + options.wrapperClassName + ' {zoom: 1;}</style>').appendTo('head');
                        }
                    }

                    // return appended element
                    return $this.parent();
                })();


                // check if we should go further
                if ($this.data('hcStickyInit')) return;
                // leave our mark
                $this.data('hcStickyInit', true);


                // check if referring element is document
                var stickTo_document = options.stickTo && (options.stickTo == 'document' || (options.stickTo.nodeType && options.stickTo.nodeType == 9) || (typeof options.stickTo == 'object' && options.stickTo instanceof(typeof HTMLDocument != 'undefined' ? HTMLDocument : Document))) ? true : false;

                // select container ;)
                var $container = options.stickTo ? stickTo_document ? $document : typeof options.stickTo == 'string' ? $(options.stickTo) : options.stickTo : $wrapper.parent();

                // clear sticky styles
                $this.css({
                    top: 'auto',
                    bottom: 'auto',
                    left: 'auto',
                    right: 'auto'
                });

                // attach event on entire page load, maybe some images inside element has been loading, so chek height again
                $window.load(function() {
                    if ($this.outerHeight(true) > $container.height()) {
                        $wrapper.css('height', $this.outerHeight(true));
                        $this.hcSticky('reinit');
                    }
                });

                // functions for attachiung and detaching sticky
                var _setFixed = function(args) {
                        // check if already floating
                        if ($this.hasClass(options.className)) return;

                        // apply styles
                        args = args || {};
                        $this.css({
                            position: 'fixed',
                            top: args.top || 0,
                            left: args.left || $wrapper.offset().left
                        }).addClass(options.className);

                        // start event
                        options.onStart.apply($this[0]);
                        // add class to wrpaeer
                        $wrapper.addClass('sticky-active');
                    },
                    _reset = function(args) {
                        args = args || {};
                        args.position = args.position || 'absolute';
                        args.top = args.top || 0;
                        args.left = args.left || 0;

                        // check if we should apply css
                        if ($this.css('position') != 'fixed' && parseInt($this.css('top')) == args.top) return;

                        // apply styles
                        $this.css({
                            position: args.position,
                            top: args.top,
                            left: args.left
                        }).removeClass(options.className);

                        // stop event
                        options.onStop.apply($this[0]);
                        // remove class from wrpaeer
                        $wrapper.removeClass('sticky-active');
                    };

                // sticky scroll function
                var onScroll = function(init) {

                    // check if we need to run sticky
                    if (!options.on || !$this.is(':visible') || $this.outerHeight(true) >= $container.height()) return;

                    var top_spacing = (options.innerSticker) ? $(options.innerSticker).position().top : ((options.innerTop) ? options.innerTop : 0),
                        wrapper_inner_top = $wrapper.offset().top,
                        bottom_limit = $container.height() - options.bottomEnd + (stickTo_document ? 0 : wrapper_inner_top),
                        top_limit = $wrapper.offset().top - options.top + top_spacing,
                        this_height = $this.outerHeight(true) + options.bottom,
                        window_height = $window.height(),
                        offset_top = $window.scrollTop(),
                        this_document_top = $this.offset().top,
                        this_window_top = this_document_top - offset_top,
                        bottom_distance;


                    // if sticky has been restarted with on/off wait for it to reach top or bottom
                    if (typeof options.remember != 'undefined' && options.remember) {

                        var position_top = this_document_top - options.top - top_spacing;

                        if (this_height - top_spacing > window_height && options.followScroll) { // element bigger than window with follow scroll on

                            if (position_top < offset_top && offset_top + window_height <= position_top + $this.height()) {
                                // element is in the middle of the screen, let our main calculations do the work
                                options.remember = false;
                            }

                        } else { // element smaller than window or follow scroll turned off

                            if (options.remember.offsetTop > position_top) {
                                // slide up
                                if (offset_top <= position_top) {
                                    _setFixed({
                                        top: options.top - top_spacing
                                    });
                                    options.remember = false;
                                }
                            } else {
                                // slide down
                                if (offset_top >= position_top) {
                                    _setFixed({
                                        top: options.top - top_spacing
                                    });
                                    options.remember = false;
                                }
                            }

                        }

                        return;
                    }


                    if (offset_top > top_limit) {

                        // http://geek-and-poke.com/geekandpoke/2012/7/27/simply-explained.html

                        if (bottom_limit + options.bottom - (options.followScroll && window_height < this_height ? 0 : options.top) <= offset_top + this_height - top_spacing - ((this_height - top_spacing > window_height - (top_limit - top_spacing) && options.followScroll) ? (((bottom_distance = this_height - window_height - top_spacing) > 0) ? bottom_distance : 0) : 0)) {
                            // bottom reached end
                            _reset({
                                top: bottom_limit - this_height + options.bottom - wrapper_inner_top
                            });
                        } else if (this_height - top_spacing > window_height && options.followScroll) {

                            if (this_window_top + this_height <= window_height) { // element bigger than window with follow scroll on

                                if (getScroll.direction == 'down') {
                                    // scroll down
                                    _setFixed({
                                        top: window_height - this_height
                                    });
                                } else {
                                    // scroll up
                                    if (this_window_top < 0 && $this.css('position') == 'fixed') {
                                        _reset({
                                            top: this_document_top - (top_limit + options.top - top_spacing) - getScroll.distanceY
                                        });
                                    }
                                }

                            } else { // element smaller than window or follow scroll turned off

                                if (getScroll.direction == 'up' && this_document_top >= offset_top + options.top - top_spacing) {
                                    // scroll up
                                    _setFixed({
                                        top: options.top - top_spacing
                                    });
                                } else if (getScroll.direction == 'down' && this_document_top + this_height > window_height && $this.css('position') == 'fixed') {
                                    // scroll down
                                    _reset({
                                        top: this_document_top - (top_limit + options.top - top_spacing) - getScroll.distanceY
                                    });
                                }

                            }
                        } else {
                            // starting (top) fixed position
                            _setFixed({
                                top: options.top - top_spacing
                            });
                        }
                    } else {
                        // reset
                        _reset();
                    }

                };


                // store resize data in case responsive is on
                var resize_timeout = false,
                    $resize_clone = false;

                var onResize = function() {

                    // check if sticky is attached to scroll event
                    attachScroll();

                    // check for off resolutions
                    checkResolutions();

                    // check if we need to run sticky
                    if (!options.on) return;

                    var setLeft = function() {
                        // set new left position
                        if ($this.css('position') == 'fixed') {
                            $this.css('left', $wrapper.offset().left);
                        } else {
                            $this.css('left', 0);
                        }
                    };

                    // check for width change (css media queries)
                    if (options.responsive) {
                        // clone element and make it invisible
                        if (!$resize_clone) {
                            $resize_clone = $this.clone().attr('style', '').css({
                                visibility: 'hidden',
                                height: 0,
                                overflow: 'hidden',
                                paddingTop: 0,
                                paddingBottom: 0,
                                marginTop: 0,
                                marginBottom: 0
                            });
                            $wrapper.after($resize_clone);
                        }

                        var wrapper_width = $wrapper.style('width');
                        var resize_clone_width = $resize_clone.style('width');

                        if (resize_clone_width == 'auto' && wrapper_width != 'auto') {
                            resize_clone_width = parseInt($this.css('width'));
                        }

                        // recalculate wrpaeer width
                        if (resize_clone_width != wrapper_width) {
                            $wrapper.width(resize_clone_width);
                        }

                        // clear previous timeout
                        if (resize_timeout) {
                            clearTimeout(resize_timeout);
                        }
                        // timedout destroing of cloned elements so we don't clone it again and again while resizing the window
                        resize_timeout = setTimeout(function() {
                            // clear timeout id
                            resize_timeout = false;
                            // destroy cloned element
                            $resize_clone.remove();
                            $resize_clone = false;
                        }, 250);
                    }

                    // set new left position
                    setLeft();

                    // recalculate inner element width (maybe original width was in %)
                    if ($this.outerWidth(true) != $wrapper.width()) {
                        var this_w = ($this.css('box-sizing') == 'border-box' || $this.css('-moz-box-sizing') == 'border-box') ? $wrapper.width() : $wrapper.width() - parseInt($this.css('padding-left')) - parseInt($this.css('padding-right'));
                        // subtract margins
                        this_w = this_w - parseInt($this.css('margin-left')) - parseInt($this.css('margin-right'));
                        // set new width
                        $this.css('width', this_w);
                    }
                };


                // remember scroll and resize callbacks so we can attach and detach them
                $this.pluginOptions('hcSticky', {
                    fn: {
                        scroll: onScroll,
                        resize: onResize
                    }
                });


                // check for off resolutions
                var checkResolutions = function() {
                    if (options.offResolutions) {
                        // convert to array
                        if (!$.isArray(options.offResolutions)) {
                            options.offResolutions = [options.offResolutions];
                        }

                        var isOn = true;

                        $.each(options.offResolutions, function(i, rez) {
                            if (rez < 0) {
                                // below
                                if ($window.width() < rez * -1) {
                                    isOn = false;
                                    $this.hcSticky('off');
                                }
                            } else {
                                // abowe
                                if ($window.width() > rez) {
                                    isOn = false;
                                    $this.hcSticky('off');
                                }
                            }
                        });

                        // turn on again
                        if (isOn && !options.on) {
                            $this.hcSticky('on');
                        }
                    }
                };
                checkResolutions();


                // attach resize function to event
                $window.on('resize', onResize);


                // attaching scroll function to event
                var attachScroll = function() {
                    var isAttached = false;
                    if ($._data(window, 'events').scroll != undefined) {
                        $.each($._data(window, 'events').scroll, function(i, f) {
                            if (f.handler == options.fn.scroll) {
                                isAttached = true;
                            }
                        });
                    }
                    if (!isAttached) {
                        // run it once to disable glitching
                        options.fn.scroll(true);
                        // attach function to scroll event only once
                        $window.on('scroll', options.fn.scroll);
                    }
                };
                attachScroll();

            });
        }
    });

})(jQuery, this);



// jQuery HC-PluginOptions
// =============
// Version: 1.0
// Copyright: Some Web Media
// Author: Some Web Guy
// Author URL: http://twitter.com/some_web_guy
// Website: http://someweblog.com/
// License: Released under the MIT License www.opensource.org/licenses/mit-license.php

(function($, undefined) {
    "use strict";

    $.fn.extend({

        pluginOptions: function(pluginName, defaultOptions, userOptions, commands) {

            // create object to store data
            if (!this.data(pluginName)) this.data(pluginName, {});

            // return options
            if (pluginName && typeof defaultOptions == 'undefined') return this.data(pluginName).options;

            // update
            userOptions = userOptions || (defaultOptions || {});

            if (typeof userOptions == 'object' || userOptions === undefined) {

                // options
                return this.each(function() {
                    var $this = $(this);

                    if (!$this.data(pluginName).options) {
                        // init our options and attach to element
                        $this.data(pluginName, {
                            options: $.extend(defaultOptions, userOptions || {})
                        });
                        // attach commands if any
                        if (commands) {
                            $this.data(pluginName).commands = commands;
                        }
                    } else {
                        // update existing options
                        $this.data(pluginName, $.extend($this.data(pluginName), {
                            options: $.extend($this.data(pluginName).options, userOptions || {})
                        }));
                    }
                });

            } else if (typeof userOptions == 'string') {

                return this.each(function() {
                    $(this).data(pluginName).commands[userOptions].call(this);
                });

            } else {

                return this;

            }

        }

    });

})(jQuery);

/*!
 * hoverIntent v1.8.1 // 2014.08.11 // jQuery v1.9.1+
 * http://cherne.net/brian/resources/jquery.hoverIntent.html
 *
 * You may use hoverIntent under the terms of the MIT license. Basically that
 * means you are free to use hoverIntent as long as this header is left intact.
 * Copyright 2007, 2014 Brian Cherne
 */

/* hoverIntent is similar to jQuery's built-in "hover" method except that
 * instead of firing the handlerIn function immediately, hoverIntent checks
 * to see if the user's mouse has slowed down (beneath the sensitivity
 * threshold) before firing the event. The handlerOut function is only
 * called after a matching handlerIn.
 *
 * // basic usage ... just like .hover()
 * .hoverIntent( handlerIn, handlerOut )
 * .hoverIntent( handlerInOut )
 *
 * // basic usage ... with event delegation!
 * .hoverIntent( handlerIn, handlerOut, selector )
 * .hoverIntent( handlerInOut, selector )
 *
 * // using a basic configuration object
 * .hoverIntent( config )
 *
 * @param  handlerIn   function OR configuration object
 * @param  handlerOut  function OR selector for delegation OR undefined
 * @param  selector    selector OR undefined
 * @author Brian Cherne <brian(at)cherne(dot)net>
 */
(function($) {
    $.fn.hoverIntent = function(handlerIn, handlerOut, selector) {

        // default configuration values
        var cfg = {
            interval: 100,
            sensitivity: 6,
            timeout: 0
        };

        if (typeof handlerIn === "object") {
            cfg = $.extend(cfg, handlerIn);
        } else if ($.isFunction(handlerOut)) {
            cfg = $.extend(cfg, {
                over: handlerIn,
                out: handlerOut,
                selector: selector
            });
        } else {
            cfg = $.extend(cfg, {
                over: handlerIn,
                out: handlerIn,
                selector: handlerOut
            });
        }

        // instantiate variables
        // cX, cY = current X and Y position of mouse, updated by mousemove event
        // pX, pY = previous X and Y position of mouse, set by mouseover and polling interval
        var cX, cY, pX, pY;

        // A private function for getting mouse position
        var track = function(ev) {
            cX = ev.pageX;
            cY = ev.pageY;
        };

        // A private function for comparing current and previous mouse position
        var compare = function(ev, ob) {
            ob.hoverIntent_t = clearTimeout(ob.hoverIntent_t);
            // compare mouse positions to see if they've crossed the threshold
            if (Math.sqrt((pX - cX) * (pX - cX) + (pY - cY) * (pY - cY)) < cfg.sensitivity) {
                $(ob).off("mousemove.hoverIntent", track);
                // set hoverIntent state to true (so mouseOut can be called)
                ob.hoverIntent_s = true;
                return cfg.over.apply(ob, [ev]);
            } else {
                // set previous coordinates for next time
                pX = cX;
                pY = cY;
                // use self-calling timeout, guarantees intervals are spaced out properly (avoids JavaScript timer bugs)
                ob.hoverIntent_t = setTimeout(function() {
                    compare(ev, ob);
                }, cfg.interval);
            }
        };

        // A private function for delaying the mouseOut function
        var delay = function(ev, ob) {
            ob.hoverIntent_t = clearTimeout(ob.hoverIntent_t);
            ob.hoverIntent_s = false;
            return cfg.out.apply(ob, [ev]);
        };

        // A private function for handling mouse 'hovering'
        var handleHover = function(e) {
            // copy objects to be passed into t (required for event object to be passed in IE)
            var ev = $.extend({}, e);
            var ob = this;

            // cancel hoverIntent timer if it exists
            if (ob.hoverIntent_t) {
                ob.hoverIntent_t = clearTimeout(ob.hoverIntent_t);
            }

            // if e.type === "mouseenter"
            if (e.type === "mouseenter") {
                // set "previous" X and Y position based on initial entry point
                pX = ev.pageX;
                pY = ev.pageY;
                // update "current" X and Y position based on mousemove
                $(ob).on("mousemove.hoverIntent", track);
                // start polling interval (self-calling timeout) to compare mouse coordinates over time
                if (!ob.hoverIntent_s) {
                    ob.hoverIntent_t = setTimeout(function() {
                        compare(ev, ob);
                    }, cfg.interval);
                }

                // else e.type == "mouseleave"
            } else {
                // unbind expensive mousemove event
                $(ob).off("mousemove.hoverIntent", track);
                // if hoverIntent state is true, then call the mouseOut function after the specified delay
                if (ob.hoverIntent_s) {
                    ob.hoverIntent_t = setTimeout(function() {
                        delay(ev, ob);
                    }, cfg.timeout);
                }
            }
        };

        // listen for mouseenter and mouseleave
        return this.on({
            'mouseenter.hoverIntent': handleHover,
            'mouseleave.hoverIntent': handleHover
        }, cfg.selector);
    };
})(jQuery);


/**
 * TotalStorage
 *
 * Copyright (c) 2012 Jared Novack & Upstatement (upstatement.com)
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 * Total Storage is the conceptual the love child of jStorage by Andris Reinman,
 * and Cookie by Klaus Hartl -- though this is not connected to either project.
 */

/**
 * Create a local storage parameter
 *
 == What makes it TOTAL Storage? ==

 * The browser doesn't support local storage it will fall-back to cookies! (Using the
   wonderful $.cookie plugin).
 * Send it strings, numbers even complex object arrays! TotalStorage does not care.
   Your efforts to defeat it will prove futile.
 * Simple as shit. jStorage and some other very well-written plugins provide a bevy of
   options for expiration, security and so forth. Frequently this is more power than you
   need and vulnerable to confusion if you're just want it to work (JWITW)

 * @desc Set the value of a key to a string
 * @example $.totalStorage('the_key', 'the_value');
 * @desc Set the value of a key to a number
 * @example $.totalStorage('the_key', 800.2);
 * @desc Set the value of a key to a complex Array
 * @example var myArray = new Array();
 *      myArray.push({name:'Jared', company:'Upstatement', zip:63124});
      myArray.push({name:'McGruff', company:'Police', zip:60652};
      $.totalStorage('people', myArray);
      //to return:
      $.totalStorage('people');
 *
 * @name $.totalStorage
 * @cat Plugins/Cookie
 * @author Jared Novack/jared@upstatement.com
 * @version 1.1.2
 * @url http://upstatement.com/blog/2012/01/jquery-local-storage-done-right-and-easy/
 */

;
(function($, undefined) {

    /* Variables I'll need throghout */

    var supported, ls, mod = 'test';
    if ('localStorage' in window) {
        try {
            ls = (typeof window.localStorage === 'undefined') ? undefined : window.localStorage;
            if (typeof ls == 'undefined' || typeof window.JSON == 'undefined') {
                supported = false;
            } else {
                supported = true;
            }

            window.localStorage.setItem(mod, '1');
            window.localStorage.removeItem(mod);
        } catch (err) {
            supported = false;
        }
    }


    /* Make the methods public */

    $.totalStorage = function(key, value, options) {
        return $.totalStorage.impl.init(key, value);
    };

    $.totalStorage.setItem = function(key, value) {
        return $.totalStorage.impl.setItem(key, value);
    };

    $.totalStorage.getItem = function(key) {
        return $.totalStorage.impl.getItem(key);
    };

    $.totalStorage.getAll = function() {
        return $.totalStorage.impl.getAll();
    };

    $.totalStorage.deleteItem = function(key) {
        return $.totalStorage.impl.deleteItem(key);
    };

    /* Object to hold all methods: public and private */

    $.totalStorage.impl = {

        init: function(key, value) {
            if (typeof value != 'undefined') {
                return this.setItem(key, value);
            } else {
                return this.getItem(key);
            }
        },

        setItem: function(key, value) {
            if (!supported) {
                try {
                    $.cookie(key, value);
                    return value;
                } catch (e) {
                    console.log('Local Storage not supported by this browser. Install the cookie plugin on your site to take advantage of the same functionality. You can get it at https://github.com/carhartl/jquery-cookie');
                }
            }
            var saver = JSON.stringify(value);
            ls.setItem(key, saver);
            return this.parseResult(saver);
        },
        getItem: function(key) {
            if (!supported) {
                try {
                    return this.parseResult($.cookie(key));
                } catch (e) {
                    return null;
                }
            }
            var item = ls.getItem(key);
            return this.parseResult(item);
        },
        deleteItem: function(key) {
            if (!supported) {
                try {
                    $.cookie(key, null);
                    return true;
                } catch (e) {
                    return false;
                }
            }
            ls.removeItem(key);
            return true;
        },
        getAll: function() {
            var items = [];
            if (!supported) {
                try {
                    var pairs = document.cookie.split(";");
                    for (var i = 0; i < pairs.length; i++) {
                        var pair = pairs[i].split('=');
                        var key = pair[0];
                        items.push({
                            key: key,
                            value: this.parseResult($.cookie(key))
                        });
                    }
                } catch (e) {
                    return null;
                }
            } else {
                for (var j in ls) {
                    if (j.length) {
                        items.push({
                            key: j,
                            value: this.parseResult(ls.getItem(j))
                        });
                    }
                }
            }
            return items;
        },
        parseResult: function(res) {
            var ret;
            try {
                ret = JSON.parse(res);
                if (typeof ret == 'undefined') {
                    ret = res;
                }
                if (ret == 'true') {
                    ret = true;
                }
                if (ret == 'false') {
                    ret = false;
                }
                if (parseFloat(ret) == ret && typeof ret != "object") {
                    ret = parseFloat(ret);
                }
            } catch (e) {
                ret = res;
            }
            return ret;
        }
    };
})(jQuery);


/*!
 * jQuery Cookie Plugin v1.4.1
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2006, 2014 Klaus Hartl
 * Released under the MIT license
 */
(function(factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD (Register as an anonymous module)
        define(['jquery'], factory);
    } else if (typeof exports === 'object') {
        // Node/CommonJS
        module.exports = factory(require('jquery'));
    } else {
        // Browser globals
        factory(jQuery);
    }
}(function($) {

    var pluses = /\+/g;

    function encode(s) {
        return config.raw ? s : encodeURIComponent(s);
    }

    function decode(s) {
        return config.raw ? s : decodeURIComponent(s);
    }

    function stringifyCookieValue(value) {
        return encode(config.json ? JSON.stringify(value) : String(value));
    }

    function parseCookieValue(s) {
        if (s.indexOf('"') === 0) {
            // This is a quoted cookie as according to RFC2068, unescape...
            s = s.slice(1, -1).replace(/\\"/g, '"').replace(/\\\\/g, '\\');
        }

        try {
            // Replace server-side written pluses with spaces.
            // If we can't decode the cookie, ignore it, it's unusable.
            // If we can't parse the cookie, ignore it, it's unusable.
            s = decodeURIComponent(s.replace(pluses, ' '));
            return config.json ? JSON.parse(s) : s;
        } catch (e) {}
    }

    function read(s, converter) {
        var value = config.raw ? s : parseCookieValue(s);
        return $.isFunction(converter) ? converter(value) : value;
    }

    var config = $.cookie = function(key, value, options) {

        // Write

        if (arguments.length > 1 && !$.isFunction(value)) {
            options = $.extend({}, config.defaults, options);

            if (typeof options.expires === 'number') {
                var days = options.expires,
                    t = options.expires = new Date();
                t.setMilliseconds(t.getMilliseconds() + days * 864e+5);
            }

            return (document.cookie = [
                encode(key), '=', stringifyCookieValue(value),
                options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
                options.path ? '; path=' + options.path : '',
                options.domain ? '; domain=' + options.domain : '',
                options.secure ? '; secure' : ''
            ].join(''));
        }

        // Read

        var result = key ? undefined : {},
            // To prevent the for loop in the first place assign an empty array
            // in case there are no cookies at all. Also prevents odd result when
            // calling $.cookie().
            cookies = document.cookie ? document.cookie.split('; ') : [],
            i = 0,
            l = cookies.length;

        for (; i < l; i++) {
            var parts = cookies[i].split('='),
                name = decode(parts.shift()),
                cookie = parts.join('=');

            if (key === name) {
                // If second argument (value) is a function it's a converter...
                result = read(cookie, value);
                break;
            }

            // Prevent storing a cookie that we couldn't decode.
            if (!key && (cookie = read(cookie)) !== undefined) {
                result[name] = cookie;
            }
        }

        return result;
    };

    config.defaults = {};

    $.removeCookie = function(key, options) {
        // Must not alter options, thus extending a fresh object...
        $.cookie(key, '', $.extend({}, options, {
            expires: -1
        }));
        return !$.cookie(key);
    };

}));


/**
 * SyntaxHighlighter
 * http://alexgorbatchev.com/SyntaxHighlighter
 *
 * SyntaxHighlighter is donationware. If you are using it, please donate.
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 3.0.83 (July 02 2010)
 *
 * @copyright
 * Copyright (C) 2004-2010 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */

/* ==========================================================================
   shCore.js
   ========================================================================== */

var XRegExp;
if (XRegExp) throw Error("can't load XRegExp twice in the same frame");
(function() {
    function r(f, e) {
        if (!XRegExp.isRegExp(f)) throw TypeError("type RegExp expected");
        var a = f._xregexp;
        f = XRegExp(f.source, t(f) + (e || ""));
        if (a) f._xregexp = {
            source: a.source,
            captureNames: a.captureNames ? a.captureNames.slice(0) : null
        };
        return f
    }

    function t(f) {
        return (f.global ? "g" : "") + (f.ignoreCase ? "i" : "") + (f.multiline ? "m" : "") + (f.extended ? "x" : "") + (f.sticky ? "y" : "")
    }

    function B(f, e, a, b) {
        var c = u.length,
            d, h, g;
        v = true;
        try {
            for (; c--;) {
                g = u[c];
                if (a & g.scope && (!g.trigger || g.trigger.call(b))) {
                    g.pattern.lastIndex = e;
                    if ((h = g.pattern.exec(f)) && h.index === e) {
                        d = {
                            output: g.handler.call(b, h, a),
                            match: h
                        };
                        break
                    }
                }
            }
        } catch (i) {
            throw i
        } finally {
            v = false
        }
        return d
    }

    function p(f, e, a) {
        if (Array.prototype.indexOf) return f.indexOf(e, a);
        for (a = a || 0; a < f.length; a++)
            if (f[a] === e) return a;
        return -1
    }
    XRegExp = function(f, e) {
        var a = [],
            b = XRegExp.OUTSIDE_CLASS,
            c = 0,
            d, h;
        if (XRegExp.isRegExp(f)) {
            if (e !== undefined) throw TypeError("can't supply flags when constructing one RegExp from another");
            return r(f)
        }
        if (v) throw Error("can't call the XRegExp constructor within token definition functions");
        e = e || "";
        for (d = {
                hasNamedCapture: false,
                captureNames: [],
                hasFlag: function(g) {
                    return e.indexOf(g) > -1
                },
                setFlag: function(g) {
                    e += g
                }
            }; c < f.length;)
            if (h = B(f, c, b, d)) {
                a.push(h.output);
                c += h.match[0].length || 1
            } else if (h = n.exec.call(z[b], f.slice(c))) {
            a.push(h[0]);
            c += h[0].length
        } else {
            h = f.charAt(c);
            if (h === "[") b = XRegExp.INSIDE_CLASS;
            else if (h === "]") b = XRegExp.OUTSIDE_CLASS;
            a.push(h);
            c++
        }
        a = RegExp(a.join(""), n.replace.call(e, w, ""));
        a._xregexp = {
            source: f,
            captureNames: d.hasNamedCapture ? d.captureNames : null
        };
        return a
    };
    XRegExp.version = "1.5.0";
    XRegExp.INSIDE_CLASS = 1;
    XRegExp.OUTSIDE_CLASS = 2;
    var C = /\$(?:(\d\d?|[$&`'])|{([$\w]+)})/g,
        w = /[^gimy]+|([\s\S])(?=[\s\S]*\1)/g,
        A = /^(?:[?*+]|{\d+(?:,\d*)?})\??/,
        v = false,
        u = [],
        n = {
            exec: RegExp.prototype.exec,
            test: RegExp.prototype.test,
            match: String.prototype.match,
            replace: String.prototype.replace,
            split: String.prototype.split
        },
        x = n.exec.call(/()??/, "")[1] === undefined,
        D = function() {
            var f = /^/g;
            n.test.call(f, "");
            return !f.lastIndex
        }(),
        y = function() {
            var f = /x/g;
            n.replace.call("x", f, "");
            return !f.lastIndex
        }(),
        E = RegExp.prototype.sticky !== undefined,
        z = {};
    z[XRegExp.INSIDE_CLASS] = /^(?:\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\dA-Fa-f]{2}|u[\dA-Fa-f]{4}|c[A-Za-z]|[\s\S]))/;
    z[XRegExp.OUTSIDE_CLASS] = /^(?:\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\d*|x[\dA-Fa-f]{2}|u[\dA-Fa-f]{4}|c[A-Za-z]|[\s\S])|\(\?[:=!]|[?*+]\?|{\d+(?:,\d*)?}\??)/;
    XRegExp.addToken = function(f, e, a, b) {
        u.push({
            pattern: r(f, "g" + (E ? "y" : "")),
            handler: e,
            scope: a || XRegExp.OUTSIDE_CLASS,
            trigger: b || null
        })
    };
    XRegExp.cache = function(f, e) {
        var a = f + "/" + (e || "");
        return XRegExp.cache[a] || (XRegExp.cache[a] = XRegExp(f, e))
    };
    XRegExp.copyAsGlobal = function(f) {
        return r(f, "g")
    };
    XRegExp.escape = function(f) {
        return f.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&")
    };
    XRegExp.execAt = function(f, e, a, b) {
        e = r(e, "g" + (b && E ? "y" : ""));
        e.lastIndex = a = a || 0;
        f = e.exec(f);
        return b ? f && f.index === a ? f : null : f
    };
    XRegExp.freezeTokens = function() {
        XRegExp.addToken = function() {
            throw Error("can't run addToken after freezeTokens")
        }
    };
    XRegExp.isRegExp = function(f) {
        return Object.prototype.toString.call(f) === "[object RegExp]"
    };
    XRegExp.iterate = function(f, e, a, b) {
        for (var c = r(e, "g"), d = -1, h; h = c.exec(f);) {
            a.call(b, h, ++d, f, c);
            c.lastIndex === h.index && c.lastIndex++
        }
        if (e.global) e.lastIndex = 0
    };
    XRegExp.matchChain = function(f, e) {
        return function a(b, c) {
            var d = e[c].regex ? e[c] : {
                    regex: e[c]
                },
                h = r(d.regex, "g"),
                g = [],
                i;
            for (i = 0; i < b.length; i++) XRegExp.iterate(b[i], h, function(k) {
                g.push(d.backref ? k[d.backref] || "" : k[0])
            });
            return c === e.length - 1 || !g.length ? g : a(g, c + 1)
        }([f], 0)
    };
    RegExp.prototype.apply = function(f, e) {
        return this.exec(e[0])
    };
    RegExp.prototype.call = function(f, e) {
        return this.exec(e)
    };
    RegExp.prototype.exec = function(f) {
        var e = n.exec.apply(this, arguments),
            a;
        if (e) {
            if (!x && e.length > 1 && p(e, "") > -1) {
                a = RegExp(this.source, n.replace.call(t(this), "g", ""));
                n.replace.call(f.slice(e.index), a, function() {
                    for (var c = 1; c < arguments.length - 2; c++)
                        if (arguments[c] === undefined) e[c] = undefined
                })
            }
            if (this._xregexp && this._xregexp.captureNames)
                for (var b = 1; b < e.length; b++)
                    if (a = this._xregexp.captureNames[b - 1]) e[a] = e[b];
                    !D && this.global && !e[0].length && this.lastIndex > e.index && this.lastIndex--
        }
        return e
    };
    if (!D) RegExp.prototype.test = function(f) {
        (f = n.exec.call(this, f)) && this.global && !f[0].length && this.lastIndex > f.index && this.lastIndex--;
        return !!f
    };
    String.prototype.match = function(f) {
        XRegExp.isRegExp(f) || (f = RegExp(f));
        if (f.global) {
            var e = n.match.apply(this, arguments);
            f.lastIndex = 0;
            return e
        }
        return f.exec(this)
    };
    String.prototype.replace = function(f, e) {
        var a = XRegExp.isRegExp(f),
            b, c;
        if (a && typeof e.valueOf() === "string" && e.indexOf("${") === -1 && y) return n.replace.apply(this, arguments);
        if (a) {
            if (f._xregexp) b = f._xregexp.captureNames
        } else f += "";
        if (typeof e === "function") c = n.replace.call(this, f, function() {
            if (b) {
                arguments[0] = new String(arguments[0]);
                for (var d = 0; d < b.length; d++)
                    if (b[d]) arguments[0][b[d]] = arguments[d + 1]
            }
            if (a && f.global) f.lastIndex = arguments[arguments.length - 2] + arguments[0].length;
            return e.apply(null, arguments)
        });
        else {
            c = this + "";
            c = n.replace.call(c, f, function() {
                var d = arguments;
                return n.replace.call(e, C, function(h, g, i) {
                    if (g) switch (g) {
                        case "$":
                            return "$";
                        case "&":
                            return d[0];
                        case "`":
                            return d[d.length - 1].slice(0, d[d.length - 2]);
                        case "'":
                            return d[d.length - 1].slice(d[d.length - 2] + d[0].length);
                        default:
                            i = "";
                            g = +g;
                            if (!g) return h;
                            for (; g > d.length - 3;) {
                                i = String.prototype.slice.call(g, -1) + i;
                                g = Math.floor(g / 10)
                            }
                            return (g ? d[g] || "" : "$") + i
                    } else {
                        g = +i;
                        if (g <= d.length - 3) return d[g];
                        g = b ? p(b, i) : -1;
                        return g > -1 ? d[g + 1] : h
                    }
                })
            })
        }
        if (a && f.global) f.lastIndex = 0;
        return c
    };
    String.prototype.split = function(f, e) {
        if (!XRegExp.isRegExp(f)) return n.split.apply(this, arguments);
        var a = this + "",
            b = [],
            c = 0,
            d, h;
        if (e === undefined || +e < 0) e = Infinity;
        else {
            e = Math.floor(+e);
            if (!e) return []
        }
        for (f = XRegExp.copyAsGlobal(f); d = f.exec(a);) {
            if (f.lastIndex > c) {
                b.push(a.slice(c, d.index));
                d.length > 1 && d.index < a.length && Array.prototype.push.apply(b, d.slice(1));
                h = d[0].length;
                c = f.lastIndex;
                if (b.length >= e) break
            }
            f.lastIndex === d.index && f.lastIndex++
        }
        if (c === a.length) {
            if (!n.test.call(f, "") || h) b.push("")
        } else b.push(a.slice(c));
        return b.length > e ? b.slice(0, e) : b
    };
    XRegExp.addToken(/\(\?#[^)]*\)/, function(f) {
        return n.test.call(A, f.input.slice(f.index + f[0].length)) ? "" : "(?:)"
    });
    XRegExp.addToken(/\((?!\?)/, function() {
        this.captureNames.push(null);
        return "("
    });
    XRegExp.addToken(/\(\?<([$\w]+)>/, function(f) {
        this.captureNames.push(f[1]);
        this.hasNamedCapture = true;
        return "("
    });
    XRegExp.addToken(/\\k<([\w$]+)>/, function(f) {
        var e = p(this.captureNames, f[1]);
        return e > -1 ? "\\" + (e + 1) + (isNaN(f.input.charAt(f.index + f[0].length)) ? "" : "(?:)") : f[0]
    });
    XRegExp.addToken(/\[\^?]/, function(f) {
        return f[0] === "[]" ? "\\b\\B" : "[\\s\\S]"
    });
    XRegExp.addToken(/^\(\?([imsx]+)\)/, function(f) {
        this.setFlag(f[1]);
        return ""
    });
    XRegExp.addToken(/(?:\s+|#.*)+/, function(f) {
        return n.test.call(A, f.input.slice(f.index + f[0].length)) ? "" : "(?:)"
    }, XRegExp.OUTSIDE_CLASS, function() {
        return this.hasFlag("x")
    });
    XRegExp.addToken(/\./, function() {
        return "[\\s\\S]"
    }, XRegExp.OUTSIDE_CLASS, function() {
        return this.hasFlag("s")
    })
})();
typeof exports != "undefined" && (exports.XRegExp = XRegExp);
var SyntaxHighlighter = function() {
    function r(a, b) {
        a.className.indexOf(b) != -1 || (a.className += " " + b)
    }

    function t(a) {
        return a.indexOf("highlighter_") == 0 ? a : "highlighter_" + a
    }

    function B(a) {
        return e.vars.highlighters[t(a)]
    }

    function p(a, b, c) {
        if (a == null) return null;
        var d = c != true ? a.childNodes : [a.parentNode],
            h = {
                "#": "id",
                ".": "className"
            }[b.substr(0, 1)] || "nodeName",
            g, i;
        g = h != "nodeName" ? b.substr(1) : b.toUpperCase();
        if ((a[h] || "").indexOf(g) != -1) return a;
        for (a = 0; d && a < d.length && i == null; a++) i = p(d[a], b, c);
        return i
    }

    function C(a, b) {
        var c = {},
            d;
        for (d in a) c[d] = a[d];
        for (d in b) c[d] = b[d];
        return c
    }

    function w(a, b, c, d) {
        function h(g) {
            g = g || window.event;
            if (!g.target) {
                g.target = g.srcElement;
                g.preventDefault = function() {
                    this.returnValue = false
                }
            }
            c.call(d || window, g)
        }
        a.attachEvent ? a.attachEvent("on" + b, h) : a.addEventListener(b, h, false)
    }

    function A(a, b) {
        var c = e.vars.discoveredBrushes,
            d = null;
        if (c == null) {
            c = {};
            for (var h in e.brushes) {
                var g = e.brushes[h];
                d = g.aliases;
                if (d != null) {
                    g.brushName = h.toLowerCase();
                    for (g = 0; g < d.length; g++) c[d[g]] = h
                }
            }
            e.vars.discoveredBrushes = c
        }
        d = e.brushes[c[a]];
        d == null && b != false && window.alert(e.config.strings.alert + (e.config.strings.noBrush + a));
        return d
    }

    function v(a, b) {
        for (var c = a.split("\n"), d = 0; d < c.length; d++) c[d] = b(c[d], d);
        return c.join("\n")
    }

    function u(a, b) {
        if (a == null || a.length == 0 || a == "\n") return a;
        a = a.replace(/</g, "&lt;");
        a = a.replace(/ {2,}/g, function(c) {
            for (var d = "", h = 0; h < c.length - 1; h++) d += e.config.space;
            return d + " "
        });
        if (b != null) a = v(a, function(c) {
            if (c.length == 0) return "";
            var d = "";
            c = c.replace(/^(&nbsp;| )+/, function(h) {
                d = h;
                return ""
            });
            if (c.length == 0) return d;
            return d + '<code class="' + b + '">' + c + "</code>"
        });
        return a
    }

    function n(a, b) {
        a.split("\n");
        for (var c = "", d = 0; d < 50; d++) c += "                    ";
        return a = v(a, function(h) {
            if (h.indexOf("\t") == -1) return h;
            for (var g = 0;
                (g = h.indexOf("\t")) != -1;) h = h.substr(0, g) + c.substr(0, b - g % b) + h.substr(g + 1, h.length);
            return h
        })
    }

    function x(a) {
        return a.replace(/^\s+|\s+$/g, "")
    }

    function D(a, b) {
        if (a.index < b.index) return -1;
        else if (a.index > b.index) return 1;
        else if (a.length < b.length) return -1;
        else if (a.length > b.length) return 1;
        return 0
    }

    function y(a, b) {
        function c(k) {
            return k[0]
        }
        for (var d = null, h = [], g = b.func ? b.func : c;
            (d = b.regex.exec(a)) != null;) {
            var i = g(d, b);
            if (typeof i == "string") i = [new e.Match(i, d.index, b.css)];
            h = h.concat(i)
        }
        return h
    }

    function E(a) {
        var b = /(.*)((&gt;|&lt;).*)/;
        return a.replace(e.regexLib.url, function(c) {
            var d = "",
                h = null;
            if (h = b.exec(c)) {
                c = h[1];
                d = h[2]
            }
            return '<a href="' + c + '">' + c + "</a>" + d
        })
    }

    function z() {
        for (var a = document.getElementsByTagName("script"), b = [], c = 0; c < a.length; c++) a[c].type == "syntaxhighlighter" && b.push(a[c]);
        return b
    }

    function f(a) {
        a = a.target;
        var b = p(a, ".syntaxhighlighter", true);
        a = p(a, ".container", true);
        var c = document.createElement("textarea");
        if (!(!a || !b || p(a, "textarea"))) {
            B(b.id);
            r(b, "source");
            for (var d = a.childNodes, h = [], g = 0; g < d.length; g++) h.push(d[g].innerText || d[g].textContent);
            h = h.join("\r");
            c.appendChild(document.createTextNode(h));
            a.appendChild(c);
            c.focus();
            c.select();
            w(c, "blur", function() {
                c.parentNode.removeChild(c);
                b.className = b.className.replace("source", "")
            })
        }
    }
    if (typeof require != "undefined" && typeof XRegExp == "undefined") XRegExp = require("XRegExp").XRegExp;
    var e = {
        defaults: {
            "class-name": "",
            "first-line": 1,
            "pad-line-numbers": false,
            highlight: null,
            title: null,
            "smart-tabs": true,
            "tab-size": 4,
            gutter: true,
            toolbar: true,
            "quick-code": true,
            collapse: false,
            "auto-links": true,
            light: false,
            "html-script": false
        },
        config: {
            space: "&nbsp;",
            useScriptTags: true,
            bloggerMode: false,
            stripBrs: false,
            tagName: "pre",
            strings: {
                expandSource: "expand source",
                help: "?",
                alert: "SyntaxHighlighter\n\n",
                noBrush: "Can't find brush for: ",
                brushNotHtmlScript: "Brush wasn't configured for html-script option: ",
                aboutDialog: '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>About SyntaxHighlighter</title></head><body style="font-family:Geneva,Arial,Helvetica,sans-serif;background-color:#fff;color:#000;font-size:1em;text-align:center;"><div style="text-align:center;margin-top:1.5em;"><div style="font-size:xx-large;">SyntaxHighlighter</div><div style="font-size:.75em;margin-bottom:3em;"><div>version 3.0.83 (July 02 2010)</div><div><a href="http://alexgorbatchev.com/SyntaxHighlighter" target="_blank" style="color:#005896">http://alexgorbatchev.com/SyntaxHighlighter</a></div><div>JavaScript code syntax highlighter.</div><div>Copyright 2004-2010 Alex Gorbatchev.</div></div><div>If you like this script, please <a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=2930402" style="color:#005896">donate</a> to <br/>keep development active!</div></div></body></html>'
            }
        },
        vars: {
            discoveredBrushes: null,
            highlighters: {}
        },
        brushes: {},
        regexLib: {
            multiLineCComments: /\/\*[\s\S]*?\*\//gm,
            singleLineCComments: /\/\/.*$/gm,
            singleLinePerlComments: /#.*$/gm,
            doubleQuotedString: /"([^\\"\n]|\\.)*"/g,
            singleQuotedString: /'([^\\'\n]|\\.)*'/g,
            multiLineDoubleQuotedString: new XRegExp('"([^\\\\"]|\\\\.)*"', "gs"),
            multiLineSingleQuotedString: new XRegExp("'([^\\\\']|\\\\.)*'", "gs"),
            xmlComments: /(&lt;|<)!--[\s\S]*?--(&gt;|>)/gm,
            url: /\w+:\/\/[\w-.\/?%&=:@;]*/g,
            phpScriptTags: {
                left: /(&lt;|<)\?=?/g,
                right: /\?(&gt;|>)/g
            },
            aspScriptTags: {
                left: /(&lt;|<)%=?/g,
                right: /%(&gt;|>)/g
            },
            scriptScriptTags: {
                left: /(&lt;|<)\s*script.*?(&gt;|>)/gi,
                right: /(&lt;|<)\/\s*script\s*(&gt;|>)/gi
            }
        },
        toolbar: {
            getHtml: function(a) {
                function b(i, k) {
                    return e.toolbar.getButtonHtml(i, k, e.config.strings[k])
                }
                for (var c = '<div class="toolbar">', d = e.toolbar.items, h = d.list, g = 0; g < h.length; g++) c += (d[h[g]].getHtml || b)(a, h[g]);
                c += "</div>";
                return c
            },
            getButtonHtml: function(a, b, c) {
                return '<span><a href="#" class="toolbar_item command_' + b + " " + b + '">' + c + "</a></span>"
            },
            handler: function(a) {
                var b = a.target,
                    c = b.className || "";
                b = B(p(b, ".syntaxhighlighter", true).id);
                var d = function(h) {
                    return (h = RegExp(h + "_(\\w+)").exec(c)) ? h[1] : null
                }("command");
                b && d && e.toolbar.items[d].execute(b);
                a.preventDefault()
            },
            items: {
                list: ["expandSource", "help"],
                expandSource: {
                    getHtml: function(a) {
                        if (a.getParam("collapse") != true) return "";
                        var b = a.getParam("title");
                        return e.toolbar.getButtonHtml(a, "expandSource", b ? b : e.config.strings.expandSource)
                    },
                    execute: function(a) {
                        a = document.getElementById(t(a.id));
                        a.className = a.className.replace("collapsed", "")
                    }
                },
                help: {
                    execute: function() {
                        var a = "scrollbars=0";
                        a += ", left=" + (screen.width - 500) / 2 + ", top=" + (screen.height - 250) / 2 + ", width=500, height=250";
                        a = a.replace(/^,/, "");
                        a = window.open("", "_blank", a);
                        a.focus();
                        var b = a.document;
                        b.write(e.config.strings.aboutDialog);
                        b.close();
                        a.focus()
                    }
                }
            }
        },
        findElements: function(a, b) {
            var c;
            if (b) c = [b];
            else {
                c = document.getElementsByTagName(e.config.tagName);
                for (var d = [], h = 0; h < c.length; h++) d.push(c[h]);
                c = d
            }
            c = c;
            d = [];
            if (e.config.useScriptTags) c = c.concat(z());
            if (c.length === 0) return d;
            for (h = 0; h < c.length; h++) {
                for (var g = c[h], i = a, k = c[h].className, j = void 0, l = {}, m = new XRegExp("^\\[(?<values>(.*?))\\]$"), s = new XRegExp("(?<name>[\\w-]+)\\s*:\\s*(?<value>[\\w-%#]+|\\[.*?\\]|\".*?\"|'.*?')\\s*;?", "g");
                    (j = s.exec(k)) != null;) {
                    var o = j.value.replace(/^['"]|['"]$/g, "");
                    if (o != null && m.test(o)) {
                        o = m.exec(o);
                        o = o.values.length > 0 ? o.values.split(/\s*,\s*/) : []
                    }
                    l[j.name] = o
                }
                g = {
                    target: g,
                    params: C(i, l)
                };
                g.params.brush != null && d.push(g)
            }
            return d
        },
        highlight: function(a, b) {
            var c = this.findElements(a, b),
                d = null,
                h = e.config;
            if (c.length !== 0)
                for (var g = 0; g < c.length; g++) {
                    b = c[g];
                    var i = b.target,
                        k = b.params,
                        j = k.brush,
                        l;
                    if (j != null) {
                        if (k["html-script"] == "true" || e.defaults["html-script"] == true) {
                            d = new e.HtmlScript(j);
                            j = "htmlscript"
                        } else if (d = A(j)) d = new d;
                        else continue;
                        l = i.innerHTML;
                        if (h.useScriptTags) {
                            l = l;
                            var m = x(l),
                                s = false;
                            if (m.indexOf("<![CDATA[") == 0) {
                                m = m.substring(9);
                                s = true
                            }
                            var o = m.length;
                            if (m.indexOf("]]\>") == o - 3) {
                                m = m.substring(0, o - 3);
                                s = true
                            }
                            l = s ? m : l
                        }
                        if ((i.title || "") != "") k.title = i.title;
                        k.brush = j;
                        d.init(k);
                        b = d.getDiv(l);
                        if ((i.id || "") != "") b.id = i.id;
                        i.parentNode.replaceChild(b, i)
                    }
                }
        },
        all: function(a) {
            w(window, "load", function() {
                e.highlight(a)
            })
        }
    };
    e.all = e.all;
    e.highlight = e.highlight;
    e.Match = function(a, b, c) {
        this.value = a;
        this.index = b;
        this.length = a.length;
        this.css = c;
        this.brushName = null
    };
    e.Match.prototype.toString = function() {
        return this.value
    };
    e.HtmlScript = function(a) {
        function b(j, l) {
            for (var m = 0; m < j.length; m++) j[m].index += l
        }
        var c = A(a),
            d, h = new e.brushes.Xml,
            g = this,
            i = "getDiv getHtml init".split(" ");
        if (c != null) {
            d = new c;
            for (var k = 0; k < i.length; k++)(function() {
                var j = i[k];
                g[j] = function() {
                    return h[j].apply(h, arguments)
                }
            })();
            d.htmlScript == null ? window.alert(e.config.strings.alert + (e.config.strings.brushNotHtmlScript + a)) : h.regexList.push({
                regex: d.htmlScript.code,
                func: function(j) {
                    for (var l = j.code, m = [], s = d.regexList, o = j.index + j.left.length, F = d.htmlScript, q, G = 0; G < s.length; G++) {
                        q = y(l, s[G]);
                        b(q, o);
                        m = m.concat(q)
                    }
                    if (F.left != null && j.left != null) {
                        q = y(j.left, F.left);
                        b(q, j.index);
                        m = m.concat(q)
                    }
                    if (F.right != null && j.right != null) {
                        q = y(j.right, F.right);
                        b(q, j.index + j[0].lastIndexOf(j.right));
                        m = m.concat(q)
                    }
                    for (j = 0; j < m.length; j++) m[j].brushName = c.brushName;
                    return m
                }
            })
        }
    };
    e.Highlighter = function() {};
    e.Highlighter.prototype = {
        getParam: function(a, b) {
            var c = this.params[a];
            c = c == null ? b : c;
            var d = {
                "true": true,
                "false": false
            }[c];
            return d == null ? c : d
        },
        create: function(a) {
            return document.createElement(a)
        },
        findMatches: function(a, b) {
            var c = [];
            if (a != null)
                for (var d = 0; d < a.length; d++)
                    if (typeof a[d] == "object") c = c.concat(y(b, a[d]));
            return this.removeNestedMatches(c.sort(D))
        },
        removeNestedMatches: function(a) {
            for (var b = 0; b < a.length; b++)
                if (a[b] !== null)
                    for (var c = a[b], d = c.index + c.length, h = b + 1; h < a.length && a[b] !== null; h++) {
                        var g = a[h];
                        if (g !== null)
                            if (g.index > d) break;
                            else if (g.index == c.index && g.length > c.length) a[b] = null;
                        else if (g.index >= c.index && g.index < d) a[h] = null
                    }
                return a
        },
        figureOutLineNumbers: function(a) {
            var b = [],
                c = parseInt(this.getParam("first-line"));
            v(a, function(d, h) {
                b.push(h + c)
            });
            return b
        },
        isLineHighlighted: function(a) {
            var b = this.getParam("highlight", []);
            if (typeof b != "object" && b.push == null) b = [b];
            a: {
                a = a.toString();
                var c = void 0;
                for (c = c = Math.max(c || 0, 0); c < b.length; c++)
                    if (b[c] == a) {
                        b = c;
                        break a
                    }
                b = -1
            }
            return b != -1
        },
        getLineHtml: function(a, b, c) {
            a = ["line", "number" + b, "index" + a, "alt" + (b % 2 == 0 ? 1 : 2).toString()];
            this.isLineHighlighted(b) && a.push("highlighted");
            b == 0 && a.push("break");
            return '<div class="' + a.join(" ") + '">' + c + "</div>"
        },
        getLineNumbersHtml: function(a, b) {
            var c = "",
                d = a.split("\n").length,
                h = parseInt(this.getParam("first-line")),
                g = this.getParam("pad-line-numbers");
            if (g == true) g = (h + d - 1).toString().length;
            else if (isNaN(g) == true) g = 0;
            for (var i = 0; i < d; i++) {
                var k = b ? b[i] : h + i,
                    j;
                if (k == 0) j = e.config.space;
                else {
                    j = g;
                    for (var l = k.toString(); l.length < j;) l = "0" + l;
                    j = l
                }
                a = j;
                c += this.getLineHtml(i, k, a)
            }
            return c
        },
        getCodeLinesHtml: function(a, b) {
            a = x(a);
            var c = a.split("\n");
            this.getParam("pad-line-numbers");
            var d = parseInt(this.getParam("first-line"));
            a = "";
            for (var h = this.getParam("brush"), g = 0; g < c.length; g++) {
                var i = c[g],
                    k = /^(&nbsp;|\s)+/.exec(i),
                    j = null,
                    l = b ? b[g] : d + g;
                if (k != null) {
                    j = k[0].toString();
                    i = i.substr(j.length);
                    j = j.replace(" ", e.config.space)
                }
                i = x(i);
                if (i.length == 0) i = e.config.space;
                a += this.getLineHtml(g, l, (j != null ? '<code class="' + h + ' spaces">' + j + "</code>" : "") + i)
            }
            return a
        },
        getTitleHtml: function(a) {
            return a ? "<caption>" + a + "</caption>" : ""
        },
        getMatchesHtml: function(a, b) {
            function c(l) {
                return (l = l ? l.brushName || g : g) ? l + " " : ""
            }
            for (var d = 0, h = "", g = this.getParam("brush", ""), i = 0; i < b.length; i++) {
                var k = b[i],
                    j;
                if (!(k === null || k.length === 0)) {
                    j = c(k);
                    h += u(a.substr(d, k.index - d), j + "plain") + u(k.value, j + k.css);
                    d = k.index + k.length + (k.offset || 0)
                }
            }
            h += u(a.substr(d), c() + "plain");
            return h
        },
        getHtml: function(a) {
            var b = "",
                c = ["syntaxhighlighter"],
                d;
            if (this.getParam("light") == true) this.params.toolbar = this.params.gutter = false;
            className = "syntaxhighlighter";
            this.getParam("collapse") == true && c.push("collapsed");
            if ((gutter = this.getParam("gutter")) == false) c.push("nogutter");
            c.push(this.getParam("class-name"));
            c.push(this.getParam("brush"));
            a = a.replace(/^[ ]*[\n]+|[\n]*[ ]*$/g, "").replace(/\r/g, " ");
            b = this.getParam("tab-size");
            if (this.getParam("smart-tabs") == true) a = n(a, b);
            else {
                for (var h = "", g = 0; g < b; g++) h += " ";
                a = a.replace(/\t/g, h)
            }
            a = a;
            a: {
                b = a = a;
                h = /<br\s*\/?>|&lt;br\s*\/?&gt;/gi;
                if (e.config.bloggerMode == true) b = b.replace(h, "\n");
                if (e.config.stripBrs == true) b = b.replace(h, "");
                b = b.split("\n");
                h = /^\s*/;
                g = 1E3;
                for (var i = 0; i < b.length && g > 0; i++) {
                    var k = b[i];
                    if (x(k).length != 0) {
                        k = h.exec(k);
                        if (k == null) {
                            a = a;
                            break a
                        }
                        g = Math.min(k[0].length, g)
                    }
                }
                if (g > 0)
                    for (i = 0; i < b.length; i++) b[i] = b[i].substr(g);
                a = b.join("\n")
            }
            if (gutter) d = this.figureOutLineNumbers(a);
            b = this.findMatches(this.regexList, a);
            b = this.getMatchesHtml(a, b);
            b = this.getCodeLinesHtml(b, d);
            if (this.getParam("auto-links")) b = E(b);
            typeof navigator != "undefined" && navigator.userAgent && navigator.userAgent.match(/MSIE/) && c.push("ie");
            return b = '<div id="' + t(this.id) + '" class="' + c.join(" ") + '">' + (this.getParam("toolbar") ? e.toolbar.getHtml(this) : "") + '<table border="0" cellpadding="0" cellspacing="0">' + this.getTitleHtml(this.getParam("title")) + "<tbody><tr>" + (gutter ? '<td class="gutter">' + this.getLineNumbersHtml(a) + "</td>" : "") + '<td class="code"><div class="container">' + b + "</div></td></tr></tbody></table></div>"
        },
        getDiv: function(a) {
            if (a === null) a = "";
            this.code = a;
            var b = this.create("div");
            b.innerHTML = this.getHtml(a);
            this.getParam("toolbar") && w(p(b, ".toolbar"), "click", e.toolbar.handler);
            this.getParam("quick-code") && w(p(b, ".code"), "dblclick", f);
            return b
        },
        init: function(a) {
            this.id = "" + Math.round(Math.random() * 1E6).toString();
            e.vars.highlighters[t(this.id)] = this;
            this.params = C(e.defaults, a || {});
            if (this.getParam("light") == true) this.params.toolbar = this.params.gutter = false
        },
        getKeywords: function(a) {
            a = a.replace(/^\s+|\s+$/g, "").replace(/\s+/g, "|");
            return "\\b(?:" + a + ")\\b"
        },
        forHtmlScript: function(a) {
            this.htmlScript = {
                left: {
                    regex: a.left,
                    css: "script"
                },
                right: {
                    regex: a.right,
                    css: "script"
                },
                code: new XRegExp("(?<left>" + a.left.source + ")(?<code>.*?)(?<right>" + a.right.source + ")", "sgi")
            }
        }
    };
    return e
}();
typeof exports != "undefined" && (exports.SyntaxHighlighter = SyntaxHighlighter);

/* ==========================================================================
   shLegacy.js
   ========================================================================== */

var dp = {
    SyntaxHighlighter: {}
};
dp.SyntaxHighlighter = {
    parseParams: function(c, k, l, m, n, o) {
        function d(a, b) {
            return a != null ? a : b
        }

        function f(a) {
            return a != null ? a.toString() : null
        }
        c = c.split(":");
        var g = c[0],
            e = {};
        reverse = {
            "true": false
        };
        result = null;
        defaults = SyntaxHighlighter.defaults;
        for (var j in c) e[c[j]] = "true";
        k = f(d(k, defaults.gutter));
        l = f(d(l, defaults.toolbar));
        m = f(d(m, defaults.collapse));
        o = f(d(o, defaults.ruler));
        n = f(d(n, defaults["first-line"]));
        return {
            brush: g,
            gutter: d(reverse[e.nogutter], k),
            toolbar: d(reverse[e.nocontrols], l),
            collapse: d({
                "true": true
            }[e.collapse], m),
            "first-line": d(function(a, b) {
                for (var h = new XRegExp("^" + b + "\\[(?<value>\\w+)\\]$", "gi"), i = null, p = 0; p < a.length; p++)
                    if ((i = h.exec(a[p])) != null) return i.value;
                return null
            }(c, "firstline"), n)
        }
    },
    HighlightAll: function(c, k, l, m, n, o) {
        function d() {
            for (var a = arguments, b = 0; b < a.length; b++)
                if (a[b] !== null) {
                    if (typeof a[b] == "string" && a[b] != "") return a[b] + "";
                    if (typeof a[b] == "object" && a[b].value != "") return a[b].value + ""
                }
            return null
        }

        function f(a, b, h) {
            h = document.getElementsByTagName(h);
            for (var i = 0; i < h.length; i++) h[i].getAttribute("name") == b && a.push(h[i])
        }
        var g = [];
        f(g, c, "pre");
        f(g, c, "textarea");
        if (g.length !== 0)
            for (c = 0; c < g.length; c++) {
                var e = g[c],
                    j = d(e.attributes["class"], e.className, e.attributes.language, e.language);
                if (j !== null) {
                    j = dp.SyntaxHighlighter.parseParams(j, k, l, m, n, o);
                    SyntaxHighlighter.highlight(j, e)
                }
            }
    }
};

/* ==========================================================================
   shBrushCSS.js
   ========================================================================== */

;
(function() {
    // CommonJS
    typeof(require) != 'undefined' ? SyntaxHighlighter = require('shCore').SyntaxHighlighter: null;

    function Brush() {
        function getKeywordsCSS(str) {
            return '\\b([a-z_]|)' + str.replace(/ /g, '(?=:)\\b|\\b([a-z_\\*]|\\*|)') + '(?=:)\\b';
        };

        function getValuesCSS(str) {
            return '\\b' + str.replace(/ /g, '(?!-)(?!:)\\b|\\b()') + '\:\\b';
        };

        var keywords = 'ascent azimuth background-attachment background-color background-image background-position ' +
            'background-repeat background baseline bbox border-collapse border-color border-spacing border-style border-top ' +
            'border-right border-bottom border-left border-top-color border-right-color border-bottom-color border-left-color ' +
            'border-top-style border-right-style border-bottom-style border-left-style border-top-width border-right-width ' +
            'border-bottom-width border-left-width border-width border bottom cap-height caption-side centerline clear clip color ' +
            'content counter-increment counter-reset cue-after cue-before cue cursor definition-src descent direction display ' +
            'elevation empty-cells float font-size-adjust font-family font-size font-stretch font-style font-variant font-weight font ' +
            'height left letter-spacing line-height list-style-image list-style-position list-style-type list-style margin-top ' +
            'margin-right margin-bottom margin-left margin marker-offset marks mathline max-height max-width min-height min-width orphans ' +
            'outline-color outline-style outline-width outline overflow padding-top padding-right padding-bottom padding-left padding page ' +
            'page-break-after page-break-before page-break-inside pause pause-after pause-before pitch pitch-range play-during position ' +
            'quotes right richness size slope src speak-header speak-numeral speak-punctuation speak speech-rate stemh stemv stress ' +
            'table-layout text-align top text-decoration text-indent text-shadow text-transform unicode-bidi unicode-range units-per-em ' +
            'vertical-align visibility voice-family volume white-space widows width widths word-spacing x-height z-index';

        var values = 'above absolute all always aqua armenian attr aural auto avoid baseline behind below bidi-override black blink block blue bold bolder ' +
            'both bottom braille capitalize caption center center-left center-right circle close-quote code collapse compact condensed ' +
            'continuous counter counters crop cross crosshair cursive dashed decimal decimal-leading-zero default digits disc dotted double ' +
            'embed embossed e-resize expanded extra-condensed extra-expanded fantasy far-left far-right fast faster fixed format fuchsia ' +
            'gray green groove handheld hebrew help hidden hide high higher icon inline-table inline inset inside invert italic ' +
            'justify landscape large larger left-side left leftwards level lighter lime line-through list-item local loud lower-alpha ' +
            'lowercase lower-greek lower-latin lower-roman lower low ltr marker maroon medium message-box middle mix move narrower ' +
            'navy ne-resize no-close-quote none no-open-quote no-repeat normal nowrap n-resize nw-resize oblique olive once open-quote outset ' +
            'outside overline pointer portrait pre print projection purple red relative repeat repeat-x repeat-y rgb ridge right right-side ' +
            'rightwards rtl run-in screen scroll semi-condensed semi-expanded separate se-resize show silent silver slower slow ' +
            'small small-caps small-caption smaller soft solid speech spell-out square s-resize static status-bar sub super sw-resize ' +
            'table-caption table-cell table-column table-column-group table-footer-group table-header-group table-row table-row-group teal ' +
            'text-bottom text-top thick thin top transparent tty tv ultra-condensed ultra-expanded underline upper-alpha uppercase upper-latin ' +
            'upper-roman url visible wait white wider w-resize x-fast x-high x-large x-loud x-low x-slow x-small x-soft xx-large xx-small yellow';

        var fonts = '[mM]onospace [tT]ahoma [vV]erdana [aA]rial [hH]elvetica [sS]ans-serif [sS]erif [cC]ourier mono sans serif';

        this.regexList = [{
                regex: SyntaxHighlighter.regexLib.multiLineCComments,
                css: 'comments'
            }, // multiline comments
            {
                regex: SyntaxHighlighter.regexLib.doubleQuotedString,
                css: 'string'
            }, // double quoted strings
            {
                regex: SyntaxHighlighter.regexLib.singleQuotedString,
                css: 'string'
            }, // single quoted strings
            {
                regex: /\#[a-fA-F0-9]{3,6}/g,
                css: 'value'
            }, // html colors
            {
                regex: /(-?\d+)(\.\d+)?(px|em|pt|\:|\%|)/g,
                css: 'value'
            }, // sizes
            {
                regex: /!important/g,
                css: 'color3'
            }, // !important
            {
                regex: new RegExp(getKeywordsCSS(keywords), 'gm'),
                css: 'keyword'
            }, // keywords
            {
                regex: new RegExp(getValuesCSS(values), 'g'),
                css: 'value'
            }, // values
            {
                regex: new RegExp(this.getKeywords(fonts), 'g'),
                css: 'color1'
            } // fonts
        ];

        this.forHtmlScript({
            left: /(&lt;|<)\s*style.*?(&gt;|>)/gi,
            right: /(&lt;|<)\/\s*style\s*(&gt;|>)/gi
        });
    };

    Brush.prototype = new SyntaxHighlighter.Highlighter();
    Brush.aliases = ['css'];

    SyntaxHighlighter.brushes.CSS = Brush;

    // CommonJS
    typeof(exports) != 'undefined' ? exports.Brush = Brush: null;
})();

/* ==========================================================================
   shBrushJScript.js
   ========================================================================== */

;
(function() {
    // CommonJS
    typeof(require) != 'undefined' ? SyntaxHighlighter = require('shCore').SyntaxHighlighter: null;

    function Brush() {
        var keywords = 'break case catch continue ' +
            'default delete do else false  ' +
            'for function if in instanceof ' +
            'new null return super switch ' +
            'this throw true try typeof var while with';

        var r = SyntaxHighlighter.regexLib;

        this.regexList = [{
                regex: r.multiLineDoubleQuotedString,
                css: 'string'
            }, // double quoted strings
            {
                regex: r.multiLineSingleQuotedString,
                css: 'string'
            }, // single quoted strings
            {
                regex: r.singleLineCComments,
                css: 'comments'
            }, // one line comments
            {
                regex: r.multiLineCComments,
                css: 'comments'
            }, // multiline comments
            {
                regex: /\s*#.*/gm,
                css: 'preprocessor'
            }, // preprocessor tags like #region and #endregion
            {
                regex: new RegExp(this.getKeywords(keywords), 'gm'),
                css: 'keyword'
            } // keywords
        ];

        this.forHtmlScript(r.scriptScriptTags);
    };

    Brush.prototype = new SyntaxHighlighter.Highlighter();
    Brush.aliases = ['js', 'jscript', 'javascript'];

    SyntaxHighlighter.brushes.JScript = Brush;

    // CommonJS
    typeof(exports) != 'undefined' ? exports.Brush = Brush: null;
})();

/* ==========================================================================
   shBrushPhp.js
   ========================================================================== */

;
(function() {
    // CommonJS
    typeof(require) != 'undefined' ? SyntaxHighlighter = require('shCore').SyntaxHighlighter: null;

    function Brush() {
        var funcs = 'abs acos acosh addcslashes addslashes ' +
            'array_change_key_case array_chunk array_combine array_count_values array_diff ' +
            'array_diff_assoc array_diff_key array_diff_uassoc array_diff_ukey array_fill ' +
            'array_filter array_flip array_intersect array_intersect_assoc array_intersect_key ' +
            'array_intersect_uassoc array_intersect_ukey array_key_exists array_keys array_map ' +
            'array_merge array_merge_recursive array_multisort array_pad array_pop array_product ' +
            'array_push array_rand array_reduce array_reverse array_search array_shift ' +
            'array_slice array_splice array_sum array_udiff array_udiff_assoc ' +
            'array_udiff_uassoc array_uintersect array_uintersect_assoc ' +
            'array_uintersect_uassoc array_unique array_unshift array_values array_walk ' +
            'array_walk_recursive atan atan2 atanh base64_decode base64_encode base_convert ' +
            'basename bcadd bccomp bcdiv bcmod bcmul bindec bindtextdomain bzclose bzcompress ' +
            'bzdecompress bzerrno bzerror bzerrstr bzflush bzopen bzread bzwrite ceil chdir ' +
            'checkdate checkdnsrr chgrp chmod chop chown chr chroot chunk_split class_exists ' +
            'closedir closelog copy cos cosh count count_chars date decbin dechex decoct ' +
            'deg2rad delete ebcdic2ascii echo empty end ereg ereg_replace eregi eregi_replace error_log ' +
            'error_reporting escapeshellarg escapeshellcmd eval exec exit exp explode extension_loaded ' +
            'feof fflush fgetc fgetcsv fgets fgetss file_exists file_get_contents file_put_contents ' +
            'fileatime filectime filegroup fileinode filemtime fileowner fileperms filesize filetype ' +
            'floatval flock floor flush fmod fnmatch fopen fpassthru fprintf fputcsv fputs fread fscanf ' +
            'fseek fsockopen fstat ftell ftok getallheaders getcwd getdate getenv gethostbyaddr gethostbyname ' +
            'gethostbynamel getimagesize getlastmod getmxrr getmygid getmyinode getmypid getmyuid getopt ' +
            'getprotobyname getprotobynumber getrandmax getrusage getservbyname getservbyport gettext ' +
            'gettimeofday gettype glob gmdate gmmktime ini_alter ini_get ini_get_all ini_restore ini_set ' +
            'interface_exists intval ip2long is_a is_array is_bool is_callable is_dir is_double ' +
            'is_executable is_file is_finite is_float is_infinite is_int is_integer is_link is_long ' +
            'is_nan is_null is_numeric is_object is_readable is_real is_resource is_scalar is_soap_fault ' +
            'is_string is_subclass_of is_uploaded_file is_writable is_writeable mkdir mktime nl2br ' +
            'parse_ini_file parse_str parse_url passthru pathinfo print readlink realpath rewind rewinddir rmdir ' +
            'round str_ireplace str_pad str_repeat str_replace str_rot13 str_shuffle str_split ' +
            'str_word_count strcasecmp strchr strcmp strcoll strcspn strftime strip_tags stripcslashes ' +
            'stripos stripslashes stristr strlen strnatcasecmp strnatcmp strncasecmp strncmp strpbrk ' +
            'strpos strptime strrchr strrev strripos strrpos strspn strstr strtok strtolower strtotime ' +
            'strtoupper strtr strval substr substr_compare';

        var keywords = 'abstract and array as break case catch cfunction class clone const continue declare default die do ' +
            'else elseif enddeclare endfor endforeach endif endswitch endwhile extends final for foreach ' +
            'function include include_once global goto if implements interface instanceof namespace new ' +
            'old_function or private protected public return require require_once static switch ' +
            'throw try use var while xor ';

        var constants = '__FILE__ __LINE__ __METHOD__ __FUNCTION__ __CLASS__';

        this.regexList = [{
                regex: SyntaxHighlighter.regexLib.singleLineCComments,
                css: 'comments'
            }, // one line comments
            {
                regex: SyntaxHighlighter.regexLib.multiLineCComments,
                css: 'comments'
            }, // multiline comments
            {
                regex: SyntaxHighlighter.regexLib.doubleQuotedString,
                css: 'string'
            }, // double quoted strings
            {
                regex: SyntaxHighlighter.regexLib.singleQuotedString,
                css: 'string'
            }, // single quoted strings
            {
                regex: /\$\w+/g,
                css: 'variable'
            }, // variables
            {
                regex: new RegExp(this.getKeywords(funcs), 'gmi'),
                css: 'functions'
            }, // common functions
            {
                regex: new RegExp(this.getKeywords(constants), 'gmi'),
                css: 'constants'
            }, // constants
            {
                regex: new RegExp(this.getKeywords(keywords), 'gm'),
                css: 'keyword'
            } // keyword
        ];

        this.forHtmlScript(SyntaxHighlighter.regexLib.phpScriptTags);
    };

    Brush.prototype = new SyntaxHighlighter.Highlighter();
    Brush.aliases = ['php'];

    SyntaxHighlighter.brushes.Php = Brush;

    // CommonJS
    typeof(exports) != 'undefined' ? exports.Brush = Brush: null;
})();

/* ==========================================================================
   shBrushPlain.js
   ========================================================================== */

;
(function() {
    // CommonJS
    typeof(require) != 'undefined' ? SyntaxHighlighter = require('shCore').SyntaxHighlighter: null;

    function Brush() {};

    Brush.prototype = new SyntaxHighlighter.Highlighter();
    Brush.aliases = ['text', 'plain'];

    SyntaxHighlighter.brushes.Plain = Brush;

    // CommonJS
    typeof(exports) != 'undefined' ? exports.Brush = Brush: null;
})();

/* ==========================================================================
   shBrushSass.js
   ========================================================================== */

;
(function() {
    // CommonJS
    typeof(require) != 'undefined' ? SyntaxHighlighter = require('shCore').SyntaxHighlighter: null;

    function Brush() {
        function getKeywordsCSS(str) {
            return '\\b([a-z_]|)' + str.replace(/ /g, '(?=:)\\b|\\b([a-z_\\*]|\\*|)') + '(?=:)\\b';
        };

        function getValuesCSS(str) {
            return '\\b' + str.replace(/ /g, '(?!-)(?!:)\\b|\\b()') + '\:\\b';
        };

        var keywords = 'ascent azimuth background-attachment background-color background-image background-position ' +
            'background-repeat background baseline bbox border-collapse border-color border-spacing border-style border-top ' +
            'border-right border-bottom border-left border-top-color border-right-color border-bottom-color border-left-color ' +
            'border-top-style border-right-style border-bottom-style border-left-style border-top-width border-right-width ' +
            'border-bottom-width border-left-width border-width border bottom cap-height caption-side centerline clear clip color ' +
            'content counter-increment counter-reset cue-after cue-before cue cursor definition-src descent direction display ' +
            'elevation empty-cells float font-size-adjust font-family font-size font-stretch font-style font-variant font-weight font ' +
            'height left letter-spacing line-height list-style-image list-style-position list-style-type list-style margin-top ' +
            'margin-right margin-bottom margin-left margin marker-offset marks mathline max-height max-width min-height min-width orphans ' +
            'outline-color outline-style outline-width outline overflow padding-top padding-right padding-bottom padding-left padding page ' +
            'page-break-after page-break-before page-break-inside pause pause-after pause-before pitch pitch-range play-during position ' +
            'quotes right richness size slope src speak-header speak-numeral speak-punctuation speak speech-rate stemh stemv stress ' +
            'table-layout text-align top text-decoration text-indent text-shadow text-transform unicode-bidi unicode-range units-per-em ' +
            'vertical-align visibility voice-family volume white-space widows width widths word-spacing x-height z-index';

        var values = 'above absolute all always aqua armenian attr aural auto avoid baseline behind below bidi-override black blink block blue bold bolder ' +
            'both bottom braille capitalize caption center center-left center-right circle close-quote code collapse compact condensed ' +
            'continuous counter counters crop cross crosshair cursive dashed decimal decimal-leading-zero digits disc dotted double ' +
            'embed embossed e-resize expanded extra-condensed extra-expanded fantasy far-left far-right fast faster fixed format fuchsia ' +
            'gray green groove handheld hebrew help hidden hide high higher icon inline-table inline inset inside invert italic ' +
            'justify landscape large larger left-side left leftwards level lighter lime line-through list-item local loud lower-alpha ' +
            'lowercase lower-greek lower-latin lower-roman lower low ltr marker maroon medium message-box middle mix move narrower ' +
            'navy ne-resize no-close-quote none no-open-quote no-repeat normal nowrap n-resize nw-resize oblique olive once open-quote outset ' +
            'outside overline pointer portrait pre print projection purple red relative repeat repeat-x repeat-y rgb ridge right right-side ' +
            'rightwards rtl run-in screen scroll semi-condensed semi-expanded separate se-resize show silent silver slower slow ' +
            'small small-caps small-caption smaller soft solid speech spell-out square s-resize static status-bar sub super sw-resize ' +
            'table-caption table-cell table-column table-column-group table-footer-group table-header-group table-row table-row-group teal ' +
            'text-bottom text-top thick thin top transparent tty tv ultra-condensed ultra-expanded underline upper-alpha uppercase upper-latin ' +
            'upper-roman url visible wait white wider w-resize x-fast x-high x-large x-loud x-low x-slow x-small x-soft xx-large xx-small yellow';

        var fonts = '[mM]onospace [tT]ahoma [vV]erdana [aA]rial [hH]elvetica [sS]ans-serif [sS]erif [cC]ourier mono sans serif';

        var statements = '!important !default';
        var preprocessor = '@import @extend @debug @warn @if @for @while @mixin @include';

        var r = SyntaxHighlighter.regexLib;

        this.regexList = [{
                regex: r.multiLineCComments,
                css: 'comments'
            }, // multiline comments
            {
                regex: r.singleLineCComments,
                css: 'comments'
            }, // singleline comments
            {
                regex: r.doubleQuotedString,
                css: 'string'
            }, // double quoted strings
            {
                regex: r.singleQuotedString,
                css: 'string'
            }, // single quoted strings
            {
                regex: /\#[a-fA-F0-9]{3,6}/g,
                css: 'value'
            }, // html colors
            {
                regex: /\b(-?\d+)(\.\d+)?(px|em|pt|\:|\%|)\b/g,
                css: 'value'
            }, // sizes
            {
                regex: /\$\w+/g,
                css: 'variable'
            }, // variables
            {
                regex: new RegExp(this.getKeywords(statements), 'g'),
                css: 'color3'
            }, // statements
            {
                regex: new RegExp(this.getKeywords(preprocessor), 'g'),
                css: 'preprocessor'
            }, // preprocessor
            {
                regex: new RegExp(getKeywordsCSS(keywords), 'gm'),
                css: 'keyword'
            }, // keywords
            {
                regex: new RegExp(getValuesCSS(values), 'g'),
                css: 'value'
            }, // values
            {
                regex: new RegExp(this.getKeywords(fonts), 'g'),
                css: 'color1'
            } // fonts
        ];
    };

    Brush.prototype = new SyntaxHighlighter.Highlighter();
    Brush.aliases = ['sass', 'scss'];

    SyntaxHighlighter.brushes.Sass = Brush;

    // CommonJS
    typeof(exports) != 'undefined' ? exports.Brush = Brush: null;
})();


/* ==========================================================================
   shBrushXml.js
   ========================================================================== */

;
(function() {
    // CommonJS
    typeof(require) != 'undefined' ? SyntaxHighlighter = require('shCore').SyntaxHighlighter: null;

    function Brush() {
        function process(match, regexInfo) {
            var constructor = SyntaxHighlighter.Match,
                code = match[0],
                tag = new XRegExp('(&lt;|<)[\\s\\/\\?]*(?<name>[:\\w-\\.]+)', 'xg').exec(code),
                result = [];

            if (match.attributes != null) {
                var attributes,
                    regex = new XRegExp('(?<name> [\\w:\\-\\.]+)' +
                        '\\s*=\\s*' +
                        '(?<value> ".*?"|\'.*?\'|\\w+)',
                        'xg');

                while ((attributes = regex.exec(code)) != null) {
                    result.push(new constructor(attributes.name, match.index + attributes.index, 'color1'));
                    result.push(new constructor(attributes.value, match.index + attributes.index + attributes[0].indexOf(attributes.value), 'string'));
                }
            }

            if (tag != null)
                result.push(
                    new constructor(tag.name, match.index + tag[0].indexOf(tag.name), 'keyword')
                );

            return result;
        }

        this.regexList = [{
                regex: new XRegExp('(\\&lt;|<)\\!\\[[\\w\\s]*?\\[(.|\\s)*?\\]\\](\\&gt;|>)', 'gm'),
                css: 'color2'
            }, // <![ ... [ ... ]]>
            {
                regex: SyntaxHighlighter.regexLib.xmlComments,
                css: 'comments'
            }, // <!-- ... -->
            {
                regex: new XRegExp('(&lt;|<)[\\s\\/\\?]*(\\w+)(?<attributes>.*?)[\\s\\/\\?]*(&gt;|>)', 'sg'),
                func: process
            }
        ];
    };

    Brush.prototype = new SyntaxHighlighter.Highlighter();
    Brush.aliases = ['xml', 'xhtml', 'xslt', 'html'];

    SyntaxHighlighter.brushes.Xml = Brush;

    // CommonJS
    typeof(exports) != 'undefined' ? exports.Brush = Brush: null;
})();

/* ==========================================================================
   shBrushRuby.js
   ========================================================================== */

;
(function() {
    // CommonJS
    typeof(require) != 'undefined' ? SyntaxHighlighter = require('shCore').SyntaxHighlighter: null;

    function Brush() {
        // Contributed by Erik Peterson.

        var keywords = 'alias and BEGIN begin break case class def define_method defined do each else elsif ' +
            'END end ensure false for if in module new next nil not or raise redo rescue retry return ' +
            'self super then throw true undef unless until when while yield';

        var builtins = 'Array Bignum Binding Class Continuation Dir Exception FalseClass File::Stat File Fixnum Fload ' +
            'Hash Integer IO MatchData Method Module NilClass Numeric Object Proc Range Regexp String Struct::TMS Symbol ' +
            'ThreadGroup Thread Time TrueClass';

        this.regexList = [{
                regex: SyntaxHighlighter.regexLib.singleLinePerlComments,
                css: 'comments'
            }, // one line comments
            {
                regex: SyntaxHighlighter.regexLib.doubleQuotedString,
                css: 'string'
            }, // double quoted strings
            {
                regex: SyntaxHighlighter.regexLib.singleQuotedString,
                css: 'string'
            }, // single quoted strings
            {
                regex: /\b[A-Z0-9_]+\b/g,
                css: 'constants'
            }, // constants
            {
                regex: /:[a-z][A-Za-z0-9_]*/g,
                css: 'color2'
            }, // symbols
            {
                regex: /(\$|@@|@)\w+/g,
                css: 'variable bold'
            }, // $global, @instance, and @@class variables
            {
                regex: new RegExp(this.getKeywords(keywords), 'gm'),
                css: 'keyword'
            }, // keywords
            {
                regex: new RegExp(this.getKeywords(builtins), 'gm'),
                css: 'color1'
            } // builtins
        ];

        this.forHtmlScript(SyntaxHighlighter.regexLib.aspScriptTags);
    };

    Brush.prototype = new SyntaxHighlighter.Highlighter();
    Brush.aliases = ['ruby', 'rails', 'ror', 'rb'];

    SyntaxHighlighter.brushes.Ruby = Brush;

    // CommonJS
    typeof(exports) != 'undefined' ? exports.Brush = Brush: null;
})();

/* ==========================================================================
   shBrushBash.js
   ========================================================================== */

;
(function() {
    // CommonJS
    typeof(require) != 'undefined' ? SyntaxHighlighter = require('shCore').SyntaxHighlighter: null;

    function Brush() {
        var keywords = 'if fi then elif else for do done until while break continue case function return in eq ne ge le';
        var commands = 'alias apropos awk basename bash bc bg builtin bzip2 cal cat cd cfdisk chgrp chmod chown chroot' +
            'cksum clear cmp comm command cp cron crontab csplit cut date dc dd ddrescue declare df ' +
            'diff diff3 dig dir dircolors dirname dirs du echo egrep eject enable env ethtool eval ' +
            'exec exit expand export expr false fdformat fdisk fg fgrep file find fmt fold format ' +
            'free fsck ftp gawk getopts grep groups gzip hash head history hostname id ifconfig ' +
            'import install join kill less let ln local locate logname logout look lpc lpr lprint ' +
            'lprintd lprintq lprm ls lsof make man mkdir mkfifo mkisofs mknod more mount mtools ' +
            'mv netstat nice nl nohup nslookup open op passwd paste pathchk ping popd pr printcap ' +
            'printenv printf ps pushd pwd quota quotacheck quotactl ram rcp read readonly renice ' +
            'remsync rm rmdir rsync screen scp sdiff sed select seq set sftp shift shopt shutdown ' +
            'sleep sort source split ssh strace su sudo sum symlink sync tail tar tee test time ' +
            'times touch top traceroute trap tr true tsort tty type ulimit umask umount unalias ' +
            'uname unexpand uniq units unset unshar useradd usermod users uuencode uudecode v vdir ' +
            'vi watch wc whereis which who whoami Wget xargs yes';

        this.regexList = [{
                regex: /^#!.*$/gm,
                css: 'preprocessor bold'
            }, {
                regex: /\/[\w-\/]+/gm,
                css: 'plain'
            }, {
                regex: SyntaxHighlighter.regexLib.singleLinePerlComments,
                css: 'comments'
            }, // one line comments
            {
                regex: SyntaxHighlighter.regexLib.doubleQuotedString,
                css: 'string'
            }, // double quoted strings
            {
                regex: SyntaxHighlighter.regexLib.singleQuotedString,
                css: 'string'
            }, // single quoted strings
            {
                regex: new RegExp(this.getKeywords(keywords), 'gm'),
                css: 'keyword'
            }, // keywords
            {
                regex: new RegExp(this.getKeywords(commands), 'gm'),
                css: 'functions'
            } // commands
        ];
    }

    Brush.prototype = new SyntaxHighlighter.Highlighter();
    Brush.aliases = ['bash', 'shell'];

    SyntaxHighlighter.brushes.Bash = Brush;

    // CommonJS
    typeof(exports) != 'undefined' ? exports.Brush = Brush: null;
})();

/* ==========================================================================
   shBrushJava.js
   ========================================================================== */

;
(function() {
    // CommonJS
    typeof(require) != 'undefined' ? SyntaxHighlighter = require('shCore').SyntaxHighlighter: null;

    function Brush() {
        var keywords = 'abstract assert boolean break byte case catch char class const ' +
            'continue default do double else enum extends ' +
            'false final finally float for goto if implements import ' +
            'instanceof int interface long native new null ' +
            'package private protected public return ' +
            'short static strictfp super switch synchronized this throw throws true ' +
            'transient try void volatile while';

        this.regexList = [{
                regex: SyntaxHighlighter.regexLib.singleLineCComments,
                css: 'comments'
            }, // one line comments
            {
                regex: /\/\*([^\*][\s\S]*)?\*\//gm,
                css: 'comments'
            }, // multiline comments
            {
                regex: /\/\*(?!\*\/)\*[\s\S]*?\*\//gm,
                css: 'preprocessor'
            }, // documentation comments
            {
                regex: SyntaxHighlighter.regexLib.doubleQuotedString,
                css: 'string'
            }, // strings
            {
                regex: SyntaxHighlighter.regexLib.singleQuotedString,
                css: 'string'
            }, // strings
            {
                regex: /\b([\d]+(\.[\d]+)?|0x[a-f0-9]+)\b/gi,
                css: 'value'
            }, // numbers
            {
                regex: /(?!\@interface\b)\@[\$\w]+\b/g,
                css: 'color1'
            }, // annotation @anno
            {
                regex: /\@interface\b/g,
                css: 'color2'
            }, // @interface keyword
            {
                regex: new RegExp(this.getKeywords(keywords), 'gm'),
                css: 'keyword'
            } // java keyword
        ];

        this.forHtmlScript({
            left: /(&lt;|<)%[@!=]?/g,
            right: /%(&gt;|>)/g
        });
    };

    Brush.prototype = new SyntaxHighlighter.Highlighter();
    Brush.aliases = ['java'];

    SyntaxHighlighter.brushes.Java = Brush;

    // CommonJS
    typeof(exports) != 'undefined' ? exports.Brush = Brush: null;
})();



// Generated by CoffeeScript 1.6.2
/*!
jQuery Waypoints - v2.0.5
Copyright (c) 2011-2014 Caleb Troughton
Licensed under the MIT license.
https://github.com/imakewebthings/jquery-waypoints/blob/master/licenses.txt
*/


(function() {
    var __indexOf = [].indexOf || function(item) {
            for (var i = 0, l = this.length; i < l; i++) {
                if (i in this && this[i] === item) return i;
            }
            return -1;
        },
        __slice = [].slice;

    (function(root, factory) {
        if (typeof define === 'function' && define.amd) {
            return define('waypoints', ['jquery'], function($) {
                return factory($, root);
            });
        } else {
            return factory(root.jQuery, root);
        }
    })(window, function($, window) {
        var $w, Context, Waypoint, allWaypoints, contextCounter, contextKey, contexts, isTouch, jQMethods, methods, resizeEvent, scrollEvent, waypointCounter, waypointKey, wp, wps;

        $w = $(window);
        isTouch = __indexOf.call(window, 'ontouchstart') >= 0;
        allWaypoints = {
            horizontal: {},
            vertical: {}
        };
        contextCounter = 1;
        contexts = {};
        contextKey = 'waypoints-context-id';
        resizeEvent = 'resize.waypoints';
        scrollEvent = 'scroll.waypoints';
        waypointCounter = 1;
        waypointKey = 'waypoints-waypoint-ids';
        wp = 'waypoint';
        wps = 'waypoints';
        Context = (function() {
            function Context($element) {
                var _this = this;

                this.$element = $element;
                this.element = $element[0];
                this.didResize = false;
                this.didScroll = false;
                this.id = 'context' + contextCounter++;
                this.oldScroll = {
                    x: $element.scrollLeft(),
                    y: $element.scrollTop()
                };
                this.waypoints = {
                    horizontal: {},
                    vertical: {}
                };
                this.element[contextKey] = this.id;
                contexts[this.id] = this;
                $element.bind(scrollEvent, function() {
                    var scrollHandler;

                    if (!(_this.didScroll || isTouch)) {
                        _this.didScroll = true;
                        scrollHandler = function() {
                            _this.doScroll();
                            return _this.didScroll = false;
                        };
                        return window.setTimeout(scrollHandler, $[wps].settings.scrollThrottle);
                    }
                });
                $element.bind(resizeEvent, function() {
                    var resizeHandler;

                    if (!_this.didResize) {
                        _this.didResize = true;
                        resizeHandler = function() {
                            $[wps]('refresh');
                            return _this.didResize = false;
                        };
                        return window.setTimeout(resizeHandler, $[wps].settings.resizeThrottle);
                    }
                });
            }

            Context.prototype.doScroll = function() {
                var axes,
                    _this = this;

                axes = {
                    horizontal: {
                        newScroll: this.$element.scrollLeft(),
                        oldScroll: this.oldScroll.x,
                        forward: 'right',
                        backward: 'left'
                    },
                    vertical: {
                        newScroll: this.$element.scrollTop(),
                        oldScroll: this.oldScroll.y,
                        forward: 'down',
                        backward: 'up'
                    }
                };
                if (isTouch && (!axes.vertical.oldScroll || !axes.vertical.newScroll)) {
                    $[wps]('refresh');
                }
                $.each(axes, function(aKey, axis) {
                    var direction, isForward, triggered;

                    triggered = [];
                    isForward = axis.newScroll > axis.oldScroll;
                    direction = isForward ? axis.forward : axis.backward;
                    $.each(_this.waypoints[aKey], function(wKey, waypoint) {
                        var _ref, _ref1;

                        if ((axis.oldScroll < (_ref = waypoint.offset) && _ref <= axis.newScroll)) {
                            return triggered.push(waypoint);
                        } else if ((axis.newScroll < (_ref1 = waypoint.offset) && _ref1 <= axis.oldScroll)) {
                            return triggered.push(waypoint);
                        }
                    });
                    triggered.sort(function(a, b) {
                        return a.offset - b.offset;
                    });
                    if (!isForward) {
                        triggered.reverse();
                    }
                    return $.each(triggered, function(i, waypoint) {
                        if (waypoint.options.continuous || i === triggered.length - 1) {
                            return waypoint.trigger([direction]);
                        }
                    });
                });
                return this.oldScroll = {
                    x: axes.horizontal.newScroll,
                    y: axes.vertical.newScroll
                };
            };

            Context.prototype.refresh = function() {
                var axes, cOffset, isWin,
                    _this = this;

                isWin = $.isWindow(this.element);
                cOffset = this.$element.offset();
                this.doScroll();
                axes = {
                    horizontal: {
                        contextOffset: isWin ? 0 : cOffset.left,
                        contextScroll: isWin ? 0 : this.oldScroll.x,
                        contextDimension: this.$element.width(),
                        oldScroll: this.oldScroll.x,
                        forward: 'right',
                        backward: 'left',
                        offsetProp: 'left'
                    },
                    vertical: {
                        contextOffset: isWin ? 0 : cOffset.top,
                        contextScroll: isWin ? 0 : this.oldScroll.y,
                        contextDimension: isWin ? $[wps]('viewportHeight') : this.$element.height(),
                        oldScroll: this.oldScroll.y,
                        forward: 'down',
                        backward: 'up',
                        offsetProp: 'top'
                    }
                };
                return $.each(axes, function(aKey, axis) {
                    return $.each(_this.waypoints[aKey], function(i, waypoint) {
                        var adjustment, elementOffset, oldOffset, _ref, _ref1;

                        adjustment = waypoint.options.offset;
                        oldOffset = waypoint.offset;
                        elementOffset = $.isWindow(waypoint.element) ? 0 : waypoint.$element.offset()[axis.offsetProp];
                        if ($.isFunction(adjustment)) {
                            adjustment = adjustment.apply(waypoint.element);
                        } else if (typeof adjustment === 'string') {
                            adjustment = parseFloat(adjustment);
                            if (waypoint.options.offset.indexOf('%') > -1) {
                                adjustment = Math.ceil(axis.contextDimension * adjustment / 100);
                            }
                        }
                        waypoint.offset = elementOffset - axis.contextOffset + axis.contextScroll - adjustment;
                        if ((waypoint.options.onlyOnScroll && (oldOffset != null)) || !waypoint.enabled) {
                            return;
                        }
                        if (oldOffset !== null && (oldOffset < (_ref = axis.oldScroll) && _ref <= waypoint.offset)) {
                            return waypoint.trigger([axis.backward]);
                        } else if (oldOffset !== null && (oldOffset > (_ref1 = axis.oldScroll) && _ref1 >= waypoint.offset)) {
                            return waypoint.trigger([axis.forward]);
                        } else if (oldOffset === null && axis.oldScroll >= waypoint.offset) {
                            return waypoint.trigger([axis.forward]);
                        }
                    });
                });
            };

            Context.prototype.checkEmpty = function() {
                if ($.isEmptyObject(this.waypoints.horizontal) && $.isEmptyObject(this.waypoints.vertical)) {
                    this.$element.unbind([resizeEvent, scrollEvent].join(' '));
                    return delete contexts[this.id];
                }
            };

            return Context;

        })();
        Waypoint = (function() {
            function Waypoint($element, context, options) {
                var idList, _ref;

                if (options.offset === 'bottom-in-view') {
                    options.offset = function() {
                        var contextHeight;

                        contextHeight = $[wps]('viewportHeight');
                        if (!$.isWindow(context.element)) {
                            contextHeight = context.$element.height();
                        }
                        return contextHeight - $(this).outerHeight();
                    };
                }
                this.$element = $element;
                this.element = $element[0];
                this.axis = options.horizontal ? 'horizontal' : 'vertical';
                this.callback = options.handler;
                this.context = context;
                this.enabled = options.enabled;
                this.id = 'waypoints' + waypointCounter++;
                this.offset = null;
                this.options = options;
                context.waypoints[this.axis][this.id] = this;
                allWaypoints[this.axis][this.id] = this;
                idList = (_ref = this.element[waypointKey]) != null ? _ref : [];
                idList.push(this.id);
                this.element[waypointKey] = idList;
            }

            Waypoint.prototype.trigger = function(args) {
                if (!this.enabled) {
                    return;
                }
                if (this.callback != null) {
                    this.callback.apply(this.element, args);
                }
                if (this.options.triggerOnce) {
                    return this.destroy();
                }
            };

            Waypoint.prototype.disable = function() {
                return this.enabled = false;
            };

            Waypoint.prototype.enable = function() {
                this.context.refresh();
                return this.enabled = true;
            };

            Waypoint.prototype.destroy = function() {
                delete allWaypoints[this.axis][this.id];
                delete this.context.waypoints[this.axis][this.id];
                return this.context.checkEmpty();
            };

            Waypoint.getWaypointsByElement = function(element) {
                var all, ids;

                ids = element[waypointKey];
                if (!ids) {
                    return [];
                }
                all = $.extend({}, allWaypoints.horizontal, allWaypoints.vertical);
                return $.map(ids, function(id) {
                    return all[id];
                });
            };

            return Waypoint;

        })();
        methods = {
            init: function(f, options) {
                var _ref;

                options = $.extend({}, $.fn[wp].defaults, options);
                if ((_ref = options.handler) == null) {
                    options.handler = f;
                }
                this.each(function() {
                    var $this, context, contextElement, _ref1;

                    $this = $(this);
                    contextElement = (_ref1 = options.context) != null ? _ref1 : $.fn[wp].defaults.context;
                    if (!$.isWindow(contextElement)) {
                        contextElement = $this.closest(contextElement);
                    }
                    contextElement = $(contextElement);
                    context = contexts[contextElement[0][contextKey]];
                    if (!context) {
                        context = new Context(contextElement);
                    }
                    return new Waypoint($this, context, options);
                });
                $[wps]('refresh');
                return this;
            },
            disable: function() {
                return methods._invoke.call(this, 'disable');
            },
            enable: function() {
                return methods._invoke.call(this, 'enable');
            },
            destroy: function() {
                return methods._invoke.call(this, 'destroy');
            },
            prev: function(axis, selector) {
                return methods._traverse.call(this, axis, selector, function(stack, index, waypoints) {
                    if (index > 0) {
                        return stack.push(waypoints[index - 1]);
                    }
                });
            },
            next: function(axis, selector) {
                return methods._traverse.call(this, axis, selector, function(stack, index, waypoints) {
                    if (index < waypoints.length - 1) {
                        return stack.push(waypoints[index + 1]);
                    }
                });
            },
            _traverse: function(axis, selector, push) {
                var stack, waypoints;

                if (axis == null) {
                    axis = 'vertical';
                }
                if (selector == null) {
                    selector = window;
                }
                waypoints = jQMethods.aggregate(selector);
                stack = [];
                this.each(function() {
                    var index;

                    index = $.inArray(this, waypoints[axis]);
                    return push(stack, index, waypoints[axis]);
                });
                return this.pushStack(stack);
            },
            _invoke: function(method) {
                this.each(function() {
                    var waypoints;

                    waypoints = Waypoint.getWaypointsByElement(this);
                    return $.each(waypoints, function(i, waypoint) {
                        waypoint[method]();
                        return true;
                    });
                });
                return this;
            }
        };
        $.fn[wp] = function() {
            var args, method;

            method = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
            if (methods[method]) {
                return methods[method].apply(this, args);
            } else if ($.isFunction(method)) {
                return methods.init.apply(this, arguments);
            } else if ($.isPlainObject(method)) {
                return methods.init.apply(this, [null, method]);
            } else if (!method) {
                return $.error("jQuery Waypoints needs a callback function or handler option.");
            } else {
                return $.error("The " + method + " method does not exist in jQuery Waypoints.");
            }
        };
        $.fn[wp].defaults = {
            context: window,
            continuous: true,
            enabled: true,
            horizontal: false,
            offset: 0,
            triggerOnce: false
        };
        jQMethods = {
            refresh: function() {
                return $.each(contexts, function(i, context) {
                    return context.refresh();
                });
            },
            viewportHeight: function() {
                var _ref;

                return (_ref = window.innerHeight) != null ? _ref : $w.height();
            },
            aggregate: function(contextSelector) {
                var collection, waypoints, _ref;

                collection = allWaypoints;
                if (contextSelector) {
                    collection = (_ref = contexts[$(contextSelector)[0][contextKey]]) != null ? _ref.waypoints : void 0;
                }
                if (!collection) {
                    return [];
                }
                waypoints = {
                    horizontal: [],
                    vertical: []
                };
                $.each(waypoints, function(axis, arr) {
                    $.each(collection[axis], function(key, waypoint) {
                        return arr.push(waypoint);
                    });
                    arr.sort(function(a, b) {
                        return a.offset - b.offset;
                    });
                    waypoints[axis] = $.map(arr, function(waypoint) {
                        return waypoint.element;
                    });
                    return waypoints[axis] = $.unique(waypoints[axis]);
                });
                return waypoints;
            },
            above: function(contextSelector) {
                if (contextSelector == null) {
                    contextSelector = window;
                }
                return jQMethods._filter(contextSelector, 'vertical', function(context, waypoint) {
                    return waypoint.offset <= context.oldScroll.y;
                });
            },
            below: function(contextSelector) {
                if (contextSelector == null) {
                    contextSelector = window;
                }
                return jQMethods._filter(contextSelector, 'vertical', function(context, waypoint) {
                    return waypoint.offset > context.oldScroll.y;
                });
            },
            left: function(contextSelector) {
                if (contextSelector == null) {
                    contextSelector = window;
                }
                return jQMethods._filter(contextSelector, 'horizontal', function(context, waypoint) {
                    return waypoint.offset <= context.oldScroll.x;
                });
            },
            right: function(contextSelector) {
                if (contextSelector == null) {
                    contextSelector = window;
                }
                return jQMethods._filter(contextSelector, 'horizontal', function(context, waypoint) {
                    return waypoint.offset > context.oldScroll.x;
                });
            },
            enable: function() {
                return jQMethods._invoke('enable');
            },
            disable: function() {
                return jQMethods._invoke('disable');
            },
            destroy: function() {
                return jQMethods._invoke('destroy');
            },
            extendFn: function(methodName, f) {
                return methods[methodName] = f;
            },
            _invoke: function(method) {
                var waypoints;

                waypoints = $.extend({}, allWaypoints.vertical, allWaypoints.horizontal);
                return $.each(waypoints, function(key, waypoint) {
                    waypoint[method]();
                    return true;
                });
            },
            _filter: function(selector, axis, test) {
                var context, waypoints;

                context = contexts[$(selector)[0][contextKey]];
                if (!context) {
                    return [];
                }
                waypoints = [];
                $.each(context.waypoints[axis], function(i, waypoint) {
                    if (test(context, waypoint)) {
                        return waypoints.push(waypoint);
                    }
                });
                waypoints.sort(function(a, b) {
                    return a.offset - b.offset;
                });
                return $.map(waypoints, function(waypoint) {
                    return waypoint.element;
                });
            }
        };
        $[wps] = function() {
            var args, method;

            method = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
            if (jQMethods[method]) {
                return jQMethods[method].apply(null, args);
            } else {
                return jQMethods.aggregate.call(null, method);
            }
        };
        $[wps].settings = {
            resizeThrottle: 100,
            scrollThrottle: 30
        };
        return $w.on('load.waypoints', function() {
            return $[wps]('refresh');
        });
    });

}).call(this);

////////////////////////////////////////////////////////////////////////////////
/* SITE SPECIFIC SCRIPT */
////////////////////////////////////////////////////////////////////////////////

$.dfp({
    dfpID: '1022251',
    refreshExisting: false,
    sizeMapping: {
        'post-general-footer-sizemap': [{
            browser: [330, 200],
            ad_sizes: [320, 100]
        }, {
            browser: [480, 200],
            ad_sizes: [468, 60]
        }, {
            browser: [768, 200],
            ad_sizes: [728, 90]
        }, {
            browser: [1000, 200],
            ad_sizes: [970, 90]
        }],
        'post-general-content_down-sizemap': [{
            browser: [450, 250],
            ad_sizes: [300, 250]
        }, {
            browser: [500, 250],
            ad_sizes: [400, 250]
        }, {
            browser: [910, 250],
            ad_sizes: [500, 250]
        }, {
            browser: [1000, 250],
            ad_sizes: [600, 250]
        }],
    }
});

(function($) {

    'use strict';

    /**
     * Control the hover effect with hoverIntent.
     */
    $(function() {

        var $hasChildren = $('.has-children'); // get menu that has '.has-children' class.

        $hasChildren.hoverIntent({
            over: function() {
                var $this = $(this);
                $this.addClass('hover');
            },
            out: function() {
                var $this = $(this);
                $this.removeClass('hover');
            },
            interval: 250,
            timeout: 200
        });

    });

    /**
     * Adding the current-menu-item class in the current active page
     */
    $(function() {
        var url = window.location.href;

        $('.menu-item a[href="' + url + '"]').addClass('current-menu-item');

        $('.menu-item a')
            .filter(function() {
                return this.href == url;
            })
            .addClass('current-menu-item');
    });


    /**
     * Make the navbar sticky
     */
    $(function() {

        var $navbar = $('#navbar'), // get the navbar element
            $navbarOffset = $navbar.offset().top; // calculate the top offset of the navbar

        function stickyNav() {
            var $scrollTop = $(window).scrollTop();

            if ($scrollTop > $navbarOffset) {
                $navbar.removeClass('no-sticky').addClass('is-sticky');
            } else {
                $navbar.removeClass('is-sticky').addClass('no-sticky');
            }
        };

        stickyNav();

        $(window).scroll(function() {
            stickyNav();
        });

    });

    /**
     * Sticky navbar open and close.
     */
    $(function() {

        var $navbar = $('#navbar'),
            $close = $('#close-nav'),
            $open = $('#open-nav'),
            $navbarHeight = $navbar.height() - 5,
            speed = 100; //ms

        $close.on('click', function(e) {
            e.preventDefault();
            $navbar.animate({
                'top': -$navbarHeight + 'px'
            }, speed);
            $open.animate({
                'top': '37px'
            }, speed);
        });

        $open.on('click', function(e) {
            var $this = $(this);
            e.preventDefault();
            $this.animate({
                'top': '-46px'
            }, speed);
            $navbar.animate({
                'top': '0'
            }, speed);
        });

    });

    /**
     *  Toggle navbar
     */
    $(function() {

        $('#panel-left').on('click', function(e) {
            e.stopPropagation();
            $('.slideable').toggleClass('reveal-left');
        });

    });

    /**
     * Refresh Socialite
     */
    $(function() {
        var share = $('.share'),
            socialised = {},
            win = $(window),
            updateArticles, onUpdate, updateTimeout;
        updateArticles = function() {
            var wT = win.scrollTop(),
                wL = win.scrollLeft(),
                wR = wL + win.width(),
                wB = wT + win.height();
            for (var i = 0; i < share.length; i++) {
                if (socialised[i]) {
                    continue;
                }
                var art = $(share[i]),
                    aT = art.offset().top,
                    aL = art.offset().left,
                    aR = aL + art.width(),
                    aB = aT + art.height();
                if ((aT >= wT && aT <= wB) || (aB >= wT && aB <= wB)) {
                    if ((aL >= wL && aL <= wR) || (aR >= wL && aR <= wR)) {
                        socialised[i] = true;
                        Socialite.load(share[i]);
                    }
                }
            }
        };
        onUpdate = function() {
            if (updateTimeout) {
                clearTimeout(updateTimeout);
            }
            updateTimeout = setTimeout(updateArticles, 100);
        };
        win.on('resize', onUpdate).on('scroll', onUpdate);

    });

})(jQuery);


(function($) {

    // Getting the elements and defining the initial values.
    var $body = $('body'),
        $sidebar = $('#secondary'),
        $getClass = $body.attr('class'),
        page = '',
        className = 0;

    /**
     * Fires the sticky sidebar.
     * @return Object hcSticky objects
     */
    function stickySidebar() {

        var $stickToEl = $('.left-panel');

        $sidebar.hcSticky({
            top: 50,
            innerSticker: '#popular-widget',
            followScroll: false,
            stickTo: $stickToEl
        });

    }

    /**
     * Get class name from the body
     * @return string the id number from the class name.
     */
    function getClassName() {
        className = $getClass.split(/\s+/);

        if ($body.hasClass('archive')) {
            className = className[3].split('-');
        } else {
            className = className[2].split('-');
        }

        return className;
    }


    /**
     * Define the page name.
     * @param  bool   $body.hasClass('') check if the body class has specified class name.
     * @return string                    the page name.
     */
    if ($body.hasClass('home')) {

        page = 'home';

    } else if ($body.hasClass('single-post')) {

        className = getClassName();
        page = 'post';

    } else {

        className = getClassName();

        if ($body.hasClass('category')) {

            page = 'category';

        } else if ($body.hasClass('author')) {

            page = 'author';

        } else if ($body.hasClass('tag')) {

            page = 'tag';

        }

    }

    // Fire the Ajax.
    $.ajax({
        type: 'POST',
        url: hkdcajax.ajaxurl,
        data: {
            action: 'ajax_sidebar',
            page: page,
            id: className[1]
        },
        success: function(result) {
            $('#secondary').append(result);
        },
        complete: function() {
            $(document).ready(function() {
                stickySidebar();
                $('.adunit-sidebar').dfp({
                    dfpID: '1022251'
                });
            });
        }
    });

}(jQuery));



/* ============================================================================
	Infinite scroll
============================================================================ */

(function($) {
    $(document).ready(function($) {
        var pageCount = 1;
        adCount = 0;
        $body = $('body'),
            $loader = $('<div>').addClass('load-infinite'),
            $container = $('#posts-list');

        $('#content').append($loader);

        function loadMoreContent() {
            pageCount++

            $adSlotID = 'adunit-inifinite-page-' + pageCount;
            $adSlotEl = $('<div>').attr({
                'class': 'adunit adunit-infinite',
                'id': $adSlotID,
                'data-adunit': 'desktop-page-infinity-300x250',
                'data-dimensions': '300x250'
            });

            if (pageCount != max_num_pages) {
                $.ajax({
                    type: 'POST',
                    url: hkdcajax.ajaxurl,
                    data: {
                        action: 'ajax_infinite',
                        page_count: pageCount
                    },
                    beforeSend: function() {
                        $loader.show();
                    },
                    success: function(result) {
                        $container.append([$adSlotEl, result]);
                        $('#' + $adSlotID).dfp({
                            dfpID: '1022251'
                        });
                    },
                    complete: function() {
                        $loader.hide();
                        $.waypoints('refresh');
                    }
                });
            }

        }

        $body.waypoint({
            handler: function(direction) {
                var $vw = $(window).width();
                var $direction = (direction === 'down' && pageCount != max_num_pages && $vw < 769);
                var $body_class = ($body.hasClass('blog') || $body.hasClass('archive') || $body.hasClass('page-template-page-menu-php'));

                if ($direction && $body_class) {
                    loadMoreContent();
                }
            },
            offset: function() {
                var contextHeight;
                contextHeight = $.waypoints('viewportHeight');
                return ((contextHeight) - $(this).outerHeight()) + 1500;
            }
        });
    });
}(jQuery));

/* ==========================================================================
   Functions run on touch device
   Patches for touch screen behaviour
   ========================================================================== */

(function() {

    if (Modernizr.touch) {
        var mobileScroller = new iScroll('touch-scroll', {
                useTransform: false,
                onBeforeScrollStart: function(e) {
                    var target = e.target;
                    while (target.nodeType != 1) target = target.parentNode;

                    if (target.tagName != 'SELECT' && target.tagName != 'INPUT' && target.tagName != 'TEXTAREA')
                        e.preventDefault();
                }
            }),

            touchScroll = document.getElementById('touch-scroll');
        touchScroll.addEventListener('touchmove', function(e) {
            e.preventDefault();
        }, false);

        touchScroll.addEventListener('DOMContentLoaded', function() {
            setTimeout(loaded, 200);
        }, false);
    }

}());